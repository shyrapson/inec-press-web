"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@iconify";
exports.ids = ["vendor-chunks/@iconify"];
exports.modules = {

/***/ "(ssr)/./node_modules/@iconify/react/dist/iconify.js":
/*!*****************************************************!*\
  !*** ./node_modules/@iconify/react/dist/iconify.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   InlineIcon: () => (/* binding */ InlineIcon),\n/* harmony export */   _api: () => (/* binding */ _api),\n/* harmony export */   addAPIProvider: () => (/* binding */ addAPIProvider),\n/* harmony export */   addCollection: () => (/* binding */ addCollection),\n/* harmony export */   addIcon: () => (/* binding */ addIcon),\n/* harmony export */   buildIcon: () => (/* binding */ iconToSVG),\n/* harmony export */   calculateSize: () => (/* binding */ calculateSize),\n/* harmony export */   getIcon: () => (/* binding */ getIcon),\n/* harmony export */   iconLoaded: () => (/* binding */ iconLoaded),\n/* harmony export */   listIcons: () => (/* binding */ listIcons),\n/* harmony export */   loadIcon: () => (/* binding */ loadIcon),\n/* harmony export */   loadIcons: () => (/* binding */ loadIcons),\n/* harmony export */   replaceIDs: () => (/* binding */ replaceIDs),\n/* harmony export */   setCustomIconLoader: () => (/* binding */ setCustomIconLoader),\n/* harmony export */   setCustomIconsLoader: () => (/* binding */ setCustomIconsLoader)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ Icon,InlineIcon,_api,addAPIProvider,addCollection,addIcon,buildIcon,calculateSize,getIcon,iconLoaded,listIcons,loadIcon,loadIcons,replaceIDs,setCustomIconLoader,setCustomIconsLoader auto */ \n/**\n* Resolve icon set icons\n*\n* Returns parent icon for each icon\n*/ function getIconsTree(data, names) {\n    const icons = data.icons;\n    const aliases = data.aliases || Object.create(null);\n    const resolved = Object.create(null);\n    function resolve(name) {\n        if (icons[name]) return resolved[name] = [];\n        if (!(name in resolved)) {\n            resolved[name] = null;\n            const parent = aliases[name] && aliases[name].parent;\n            const value = parent && resolve(parent);\n            if (value) resolved[name] = [\n                parent\n            ].concat(value);\n        }\n        return resolved[name];\n    }\n    Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);\n    return resolved;\n}\n/**\n* Default values for dimensions\n*/ const defaultIconDimensions = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n});\n/**\n* Default values for transformations\n*/ const defaultIconTransformations = Object.freeze({\n    rotate: 0,\n    vFlip: false,\n    hFlip: false\n});\n/**\n* Default values for all optional IconifyIcon properties\n*/ const defaultIconProps = Object.freeze({\n    ...defaultIconDimensions,\n    ...defaultIconTransformations\n});\n/**\n* Default values for all properties used in ExtendedIconifyIcon\n*/ const defaultExtendedIconProps = Object.freeze({\n    ...defaultIconProps,\n    body: \"\",\n    hidden: false\n});\n/**\n* Merge transformations\n*/ function mergeIconTransformations(obj1, obj2) {\n    const result = {};\n    if (!obj1.hFlip !== !obj2.hFlip) result.hFlip = true;\n    if (!obj1.vFlip !== !obj2.vFlip) result.vFlip = true;\n    const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n    if (rotate) result.rotate = rotate;\n    return result;\n}\n/**\n* Merge icon and alias\n*\n* Can also be used to merge default values and icon\n*/ function mergeIconData(parent, child) {\n    const result = mergeIconTransformations(parent, child);\n    for(const key in defaultExtendedIconProps)if (key in defaultIconTransformations) {\n        if (key in parent && !(key in result)) result[key] = defaultIconTransformations[key];\n    } else if (key in child) result[key] = child[key];\n    else if (key in parent) result[key] = parent[key];\n    return result;\n}\n/**\n* Get icon data, using prepared aliases tree\n*/ function internalGetIconData(data, name, tree) {\n    const icons = data.icons;\n    const aliases = data.aliases || Object.create(null);\n    let currentProps = {};\n    function parse(name$1) {\n        currentProps = mergeIconData(icons[name$1] || aliases[name$1], currentProps);\n    }\n    parse(name);\n    tree.forEach(parse);\n    return mergeIconData(data, currentProps);\n}\n/**\n* Extract icons from an icon set\n*\n* Returns list of icons that were found in icon set\n*/ function parseIconSet(data, callback) {\n    const names = [];\n    if (typeof data !== \"object\" || typeof data.icons !== \"object\") return names;\n    if (data.not_found instanceof Array) data.not_found.forEach((name)=>{\n        callback(name, null);\n        names.push(name);\n    });\n    const tree = getIconsTree(data);\n    for(const name in tree){\n        const item = tree[name];\n        if (item) {\n            callback(name, internalGetIconData(data, name, item));\n            names.push(name);\n        }\n    }\n    return names;\n}\n/**\n* Optional properties\n*/ const optionalPropertyDefaults = {\n    provider: \"\",\n    aliases: {},\n    not_found: {},\n    ...defaultIconDimensions\n};\n/**\n* Check props\n*/ function checkOptionalProps(item, defaults) {\n    for(const prop in defaults)if (prop in item && typeof item[prop] !== typeof defaults[prop]) return false;\n    return true;\n}\n/**\n* Validate icon set, return it as IconifyJSON on success, null on failure\n*\n* Unlike validateIconSet(), this function is very basic.\n* It does not throw exceptions, it does not check metadata, it does not fix stuff.\n*/ function quicklyValidateIconSet(obj) {\n    if (typeof obj !== \"object\" || obj === null) return null;\n    const data = obj;\n    if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") return null;\n    if (!checkOptionalProps(obj, optionalPropertyDefaults)) return null;\n    const icons = data.icons;\n    for(const name in icons){\n        const icon = icons[name];\n        if (!name || typeof icon.body !== \"string\" || !checkOptionalProps(icon, defaultExtendedIconProps)) return null;\n    }\n    const aliases = data.aliases || Object.create(null);\n    for(const name in aliases){\n        const icon = aliases[name];\n        const parent = icon.parent;\n        if (!name || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon, defaultExtendedIconProps)) return null;\n    }\n    return data;\n}\n/**\n* Storage by provider and prefix\n*/ const dataStorage = Object.create(null);\n/**\n* Create new storage\n*/ function newStorage(provider, prefix) {\n    return {\n        provider,\n        prefix,\n        icons: Object.create(null),\n        missing: /* @__PURE__ */ new Set()\n    };\n}\n/**\n* Get storage for provider and prefix\n*/ function getStorage(provider, prefix) {\n    const providerStorage = dataStorage[provider] || (dataStorage[provider] = Object.create(null));\n    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\n/**\n* Add icon set to storage\n*\n* Returns array of added icons\n*/ function addIconSet(storage, data) {\n    if (!quicklyValidateIconSet(data)) return [];\n    return parseIconSet(data, (name, icon)=>{\n        if (icon) storage.icons[name] = icon;\n        else storage.missing.add(name);\n    });\n}\n/**\n* Add icon to storage\n*/ function addIconToStorage(storage, name, icon) {\n    try {\n        if (typeof icon.body === \"string\") {\n            storage.icons[name] = {\n                ...icon\n            };\n            return true;\n        }\n    } catch (err) {}\n    return false;\n}\n/**\n* List available icons\n*/ function listIcons(provider, prefix) {\n    let allIcons = [];\n    const providers = typeof provider === \"string\" ? [\n        provider\n    ] : Object.keys(dataStorage);\n    providers.forEach((provider$1)=>{\n        const prefixes = typeof provider$1 === \"string\" && typeof prefix === \"string\" ? [\n            prefix\n        ] : Object.keys(dataStorage[provider$1] || {});\n        prefixes.forEach((prefix$1)=>{\n            const storage = getStorage(provider$1, prefix$1);\n            allIcons = allIcons.concat(Object.keys(storage.icons).map((name)=>(provider$1 !== \"\" ? \"@\" + provider$1 + \":\" : \"\") + prefix$1 + \":\" + name));\n        });\n    });\n    return allIcons;\n}\n/**\n* Expression to test part of icon name.\n*\n* Used when loading icons from Iconify API due to project naming convension.\n* Ignored when using custom icon sets - convension does not apply.\n*/ const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\n/**\n* Convert string icon name to IconifyIconName object.\n*/ const stringToIcon = (value, validate, allowSimpleName, provider = \"\")=>{\n    const colonSeparated = value.split(\":\");\n    if (value.slice(0, 1) === \"@\") {\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) return null;\n        provider = colonSeparated.shift().slice(1);\n    }\n    if (colonSeparated.length > 3 || !colonSeparated.length) return null;\n    if (colonSeparated.length > 1) {\n        const name$1 = colonSeparated.pop();\n        const prefix = colonSeparated.pop();\n        const result = {\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix,\n            name: name$1\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    const name = colonSeparated[0];\n    const dashSeparated = name.split(\"-\");\n    if (dashSeparated.length > 1) {\n        const result = {\n            provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join(\"-\")\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    if (allowSimpleName && provider === \"\") {\n        const result = {\n            provider,\n            prefix: \"\",\n            name\n        };\n        return validate && !validateIconName(result, allowSimpleName) ? null : result;\n    }\n    return null;\n};\n/**\n* Check if icon is valid.\n*\n* This function is not part of stringToIcon because validation is not needed for most code.\n*/ const validateIconName = (icon, allowSimpleName)=>{\n    if (!icon) return false;\n    return !!((allowSimpleName && icon.prefix === \"\" || !!icon.prefix) && !!icon.name);\n};\n/**\n* Allow storing icons without provider or prefix, making it possible to store icons like \"home\"\n*/ let simpleNames = false;\nfunction allowSimpleNames(allow) {\n    if (typeof allow === \"boolean\") simpleNames = allow;\n    return simpleNames;\n}\n/**\n* Get icon data\n*\n* Returns:\n* - IconifyIcon on success, object directly from storage so don't modify it\n* - null if icon is marked as missing (returned in `not_found` property from API, so don't bother sending API requests)\n* - undefined if icon is missing in storage\n*/ function getIconData(name) {\n    const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n    if (icon) {\n        const storage = getStorage(icon.provider, icon.prefix);\n        const iconName = icon.name;\n        return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n    }\n}\n/**\n* Add one icon\n*/ function addIcon(name, data) {\n    const icon = stringToIcon(name, true, simpleNames);\n    if (!icon) return false;\n    const storage = getStorage(icon.provider, icon.prefix);\n    if (data) return addIconToStorage(storage, icon.name, data);\n    else {\n        storage.missing.add(icon.name);\n        return true;\n    }\n}\n/**\n* Add icon set\n*/ function addCollection(data, provider) {\n    if (typeof data !== \"object\") return false;\n    if (typeof provider !== \"string\") provider = data.provider || \"\";\n    if (simpleNames && !provider && !data.prefix) {\n        let added = false;\n        if (quicklyValidateIconSet(data)) {\n            data.prefix = \"\";\n            parseIconSet(data, (name, icon)=>{\n                if (addIcon(name, icon)) added = true;\n            });\n        }\n        return added;\n    }\n    const prefix = data.prefix;\n    if (!validateIconName({\n        prefix,\n        name: \"a\"\n    })) return false;\n    const storage = getStorage(provider, prefix);\n    return !!addIconSet(storage, data);\n}\n/**\n* Check if icon data is available\n*/ function iconLoaded(name) {\n    return !!getIconData(name);\n}\n/**\n* Get full icon\n*/ function getIcon(name) {\n    const result = getIconData(name);\n    return result ? {\n        ...defaultIconProps,\n        ...result\n    } : result;\n}\n/**\n* Default icon customisations values\n*/ const defaultIconSizeCustomisations = Object.freeze({\n    width: null,\n    height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n    ...defaultIconSizeCustomisations,\n    ...defaultIconTransformations\n});\n/**\n* Regular expressions for calculating dimensions\n*/ const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n    if (ratio === 1) return size;\n    precision = precision || 100;\n    if (typeof size === \"number\") return Math.ceil(size * ratio * precision) / precision;\n    if (typeof size !== \"string\") return size;\n    const oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) return size;\n    const newParts = [];\n    let code = oldParts.shift();\n    let isNumber = unitsTest.test(code);\n    while(true){\n        if (isNumber) {\n            const num = parseFloat(code);\n            if (isNaN(num)) newParts.push(code);\n            else newParts.push(Math.ceil(num * ratio * precision) / precision);\n        } else newParts.push(code);\n        code = oldParts.shift();\n        if (code === void 0) return newParts.join(\"\");\n        isNumber = !isNumber;\n    }\n}\nfunction splitSVGDefs(content, tag = \"defs\") {\n    let defs = \"\";\n    const index = content.indexOf(\"<\" + tag);\n    while(index >= 0){\n        const start = content.indexOf(\">\", index);\n        const end = content.indexOf(\"</\" + tag);\n        if (start === -1 || end === -1) break;\n        const endEnd = content.indexOf(\">\", end);\n        if (endEnd === -1) break;\n        defs += content.slice(start + 1, end).trim();\n        content = content.slice(0, index).trim() + content.slice(endEnd + 1);\n    }\n    return {\n        defs,\n        content\n    };\n}\n/**\n* Merge defs and content\n*/ function mergeDefsAndContent(defs, content) {\n    return defs ? \"<defs>\" + defs + \"</defs>\" + content : content;\n}\n/**\n* Wrap SVG content, without wrapping definitions\n*/ function wrapSVGContent(body, start, end) {\n    const split = splitSVGDefs(body);\n    return mergeDefsAndContent(split.defs, start + split.content + end);\n}\n/**\n* Check if value should be unset. Allows multiple keywords\n*/ const isUnsetKeyword = (value)=>value === \"unset\" || value === \"undefined\" || value === \"none\";\n/**\n* Get SVG attributes and content from icon + customisations\n*\n* Does not generate style to make it compatible with frameworks that use objects for style, such as React.\n* Instead, it generates 'inline' value. If true, rendering engine should add verticalAlign: -0.125em to icon.\n*\n* Customisations should be normalised by platform specific parser.\n* Result should be converted to <svg> by platform specific parser.\n* Use replaceIDs to generate unique IDs for body.\n*/ function iconToSVG(icon, customisations) {\n    const fullIcon = {\n        ...defaultIconProps,\n        ...icon\n    };\n    const fullCustomisations = {\n        ...defaultIconCustomisations,\n        ...customisations\n    };\n    const box = {\n        left: fullIcon.left,\n        top: fullIcon.top,\n        width: fullIcon.width,\n        height: fullIcon.height\n    };\n    let body = fullIcon.body;\n    [\n        fullIcon,\n        fullCustomisations\n    ].forEach((props)=>{\n        const transformations = [];\n        const hFlip = props.hFlip;\n        const vFlip = props.vFlip;\n        let rotation = props.rotate;\n        if (hFlip) if (vFlip) rotation += 2;\n        else {\n            transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n            transformations.push(\"scale(-1 1)\");\n            box.top = box.left = 0;\n        }\n        else if (vFlip) {\n            transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n            transformations.push(\"scale(1 -1)\");\n            box.top = box.left = 0;\n        }\n        let tempValue;\n        if (rotation < 0) rotation -= Math.floor(rotation / 4) * 4;\n        rotation = rotation % 4;\n        switch(rotation){\n            case 1:\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n            case 2:\n                transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n                break;\n            case 3:\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n        }\n        if (rotation % 2 === 1) {\n            if (box.left !== box.top) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) body = wrapSVGContent(body, '<g transform=\"' + transformations.join(\" \") + '\">', \"</g>\");\n    });\n    const customisationsWidth = fullCustomisations.width;\n    const customisationsHeight = fullCustomisations.height;\n    const boxWidth = box.width;\n    const boxHeight = box.height;\n    let width;\n    let height;\n    if (customisationsWidth === null) {\n        height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n        width = calculateSize(height, boxWidth / boxHeight);\n    } else {\n        width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n        height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    }\n    const attributes = {};\n    const setAttr = (prop, value)=>{\n        if (!isUnsetKeyword(value)) attributes[prop] = value.toString();\n    };\n    setAttr(\"width\", width);\n    setAttr(\"height\", height);\n    const viewBox = [\n        box.left,\n        box.top,\n        boxWidth,\n        boxHeight\n    ];\n    attributes.viewBox = viewBox.join(\" \");\n    return {\n        attributes,\n        viewBox,\n        body\n    };\n}\n/**\n* IDs usage:\n*\n* id=\"{id}\"\n* xlink:href=\"#{id}\"\n* url(#{id})\n*\n* From SVG animations:\n*\n* begin=\"0;{id}.end\"\n* begin=\"{id}.end\"\n* begin=\"{id}.click\"\n*/ /**\n* Regular expression for finding ids\n*/ const regex = /\\sid=\"(\\S+)\"/g;\n/**\n* New random-ish prefix for ids\n*\n* Do not use dash, it cannot be used in SVG 2 animations\n*/ const randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\n/**\n* Counter for ids, increasing with every replacement\n*/ let counter = 0;\n/**\n* Replace IDs in SVG output with unique IDs\n*/ function replaceIDs(body, prefix = randomPrefix) {\n    const ids = [];\n    let match;\n    while(match = regex.exec(body))ids.push(match[1]);\n    if (!ids.length) return body;\n    const suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n    ids.forEach((id)=>{\n        const newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n        const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        body = body.replace(new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"), \"$1\" + newID + suffix + \"$3\");\n    });\n    body = body.replace(new RegExp(suffix, \"g\"), \"\");\n    return body;\n}\n/**\n* Local storate types and entries\n*/ const storage = Object.create(null);\n/**\n* Set API module\n*/ function setAPIModule(provider, item) {\n    storage[provider] = item;\n}\n/**\n* Get API module\n*/ function getAPIModule(provider) {\n    return storage[provider] || storage[\"\"];\n}\n/**\n* Create full API configuration from partial data\n*/ function createAPIConfig(source) {\n    let resources;\n    if (typeof source.resources === \"string\") resources = [\n        source.resources\n    ];\n    else {\n        resources = source.resources;\n        if (!(resources instanceof Array) || !resources.length) return null;\n    }\n    const result = {\n        resources,\n        path: source.path || \"/\",\n        maxURL: source.maxURL || 500,\n        rotate: source.rotate || 750,\n        timeout: source.timeout || 5e3,\n        random: source.random === true,\n        index: source.index || 0,\n        dataAfterTimeout: source.dataAfterTimeout !== false\n    };\n    return result;\n}\n/**\n* Local storage\n*/ const configStorage = Object.create(null);\n/**\n* Redundancy for API servers.\n*\n* API should have very high uptime because of implemented redundancy at server level, but\n* sometimes bad things happen. On internet 100% uptime is not possible.\n*\n* There could be routing problems. Server might go down for whatever reason, but it takes\n* few minutes to detect that downtime, so during those few minutes API might not be accessible.\n*\n* This script has some redundancy to mitigate possible network issues.\n*\n* If one host cannot be reached in 'rotate' (750 by default) ms, script will try to retrieve\n* data from different host. Hosts have different configurations, pointing to different\n* API servers hosted at different providers.\n*/ const fallBackAPISources = [\n    \"https://api.simplesvg.com\",\n    \"https://api.unisvg.com\"\n];\nconst fallBackAPI = [];\nwhile(fallBackAPISources.length > 0)if (fallBackAPISources.length === 1) fallBackAPI.push(fallBackAPISources.shift());\nelse if (Math.random() > .5) fallBackAPI.push(fallBackAPISources.shift());\nelse fallBackAPI.push(fallBackAPISources.pop());\nconfigStorage[\"\"] = createAPIConfig({\n    resources: [\n        \"https://api.iconify.design\"\n    ].concat(fallBackAPI)\n});\n/**\n* Add custom config for provider\n*/ function addAPIProvider(provider, customConfig) {\n    const config = createAPIConfig(customConfig);\n    if (config === null) return false;\n    configStorage[provider] = config;\n    return true;\n}\n/**\n* Get API configuration\n*/ function getAPIConfig(provider) {\n    return configStorage[provider];\n}\n/**\n* List API providers\n*/ function listAPIProviders() {\n    return Object.keys(configStorage);\n}\nconst detectFetch = ()=>{\n    let callback;\n    try {\n        callback = fetch;\n        if (typeof callback === \"function\") return callback;\n    } catch (err) {}\n};\n/**\n* Fetch function\n*/ let fetchModule = detectFetch();\n/**\n* Set custom fetch() function\n*/ function setFetch(fetch$1) {\n    fetchModule = fetch$1;\n}\n/**\n* Get fetch() function. Used by Icon Finder Core\n*/ function getFetch() {\n    return fetchModule;\n}\n/**\n* Calculate maximum icons list length for prefix\n*/ function calculateMaxLength(provider, prefix) {\n    const config = getAPIConfig(provider);\n    if (!config) return 0;\n    let result;\n    if (!config.maxURL) result = 0;\n    else {\n        let maxHostLength = 0;\n        config.resources.forEach((item)=>{\n            const host = item;\n            maxHostLength = Math.max(maxHostLength, host.length);\n        });\n        const url = prefix + \".json?icons=\";\n        result = config.maxURL - maxHostLength - config.path.length - url.length;\n    }\n    return result;\n}\n/**\n* Should query be aborted, based on last HTTP status\n*/ function shouldAbort(status) {\n    return status === 404;\n}\n/**\n* Prepare params\n*/ const prepare = (provider, prefix, icons)=>{\n    const results = [];\n    const maxLength = calculateMaxLength(provider, prefix);\n    const type = \"icons\";\n    let item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n    };\n    let length = 0;\n    icons.forEach((name, index)=>{\n        length += name.length + 1;\n        if (length >= maxLength && index > 0) {\n            results.push(item);\n            item = {\n                type,\n                provider,\n                prefix,\n                icons: []\n            };\n            length = name.length;\n        }\n        item.icons.push(name);\n    });\n    results.push(item);\n    return results;\n};\n/**\n* Get path\n*/ function getPath(provider) {\n    if (typeof provider === \"string\") {\n        const config = getAPIConfig(provider);\n        if (config) return config.path;\n    }\n    return \"/\";\n}\n/**\n* Load icons\n*/ const send = (host, params, callback)=>{\n    if (!fetchModule) {\n        callback(\"abort\", 424);\n        return;\n    }\n    let path = getPath(params.provider);\n    switch(params.type){\n        case \"icons\":\n            {\n                const prefix = params.prefix;\n                const icons = params.icons;\n                const iconsList = icons.join(\",\");\n                const urlParams = new URLSearchParams({\n                    icons: iconsList\n                });\n                path += prefix + \".json?\" + urlParams.toString();\n                break;\n            }\n        case \"custom\":\n            {\n                const uri = params.uri;\n                path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n                break;\n            }\n        default:\n            callback(\"abort\", 400);\n            return;\n    }\n    let defaultError = 503;\n    fetchModule(host + path).then((response)=>{\n        const status = response.status;\n        if (status !== 200) {\n            setTimeout(()=>{\n                callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n            });\n            return;\n        }\n        defaultError = 501;\n        return response.json();\n    }).then((data)=>{\n        if (typeof data !== \"object\" || data === null) {\n            setTimeout(()=>{\n                if (data === 404) callback(\"abort\", data);\n                else callback(\"next\", defaultError);\n            });\n            return;\n        }\n        setTimeout(()=>{\n            callback(\"success\", data);\n        });\n    }).catch(()=>{\n        callback(\"next\", defaultError);\n    });\n};\n/**\n* Export module\n*/ const fetchAPIModule = {\n    prepare,\n    send\n};\n/**\n* Remove callback\n*/ function removeCallback(storages, id) {\n    storages.forEach((storage)=>{\n        const items = storage.loaderCallbacks;\n        if (items) storage.loaderCallbacks = items.filter((row)=>row.id !== id);\n    });\n}\n/**\n* Update all callbacks for provider and prefix\n*/ function updateCallbacks(storage) {\n    if (!storage.pendingCallbacksFlag) {\n        storage.pendingCallbacksFlag = true;\n        setTimeout(()=>{\n            storage.pendingCallbacksFlag = false;\n            const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n            if (!items.length) return;\n            let hasPending = false;\n            const provider = storage.provider;\n            const prefix = storage.prefix;\n            items.forEach((item)=>{\n                const icons = item.icons;\n                const oldLength = icons.pending.length;\n                icons.pending = icons.pending.filter((icon)=>{\n                    if (icon.prefix !== prefix) return true;\n                    const name = icon.name;\n                    if (storage.icons[name]) icons.loaded.push({\n                        provider,\n                        prefix,\n                        name\n                    });\n                    else if (storage.missing.has(name)) icons.missing.push({\n                        provider,\n                        prefix,\n                        name\n                    });\n                    else {\n                        hasPending = true;\n                        return true;\n                    }\n                    return false;\n                });\n                if (icons.pending.length !== oldLength) {\n                    if (!hasPending) removeCallback([\n                        storage\n                    ], item.id);\n                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n                }\n            });\n        });\n    }\n}\n/**\n* Unique id counter for callbacks\n*/ let idCounter = 0;\n/**\n* Add callback\n*/ function storeCallback(callback, icons, pendingSources) {\n    const id = idCounter++;\n    const abort = removeCallback.bind(null, pendingSources, id);\n    if (!icons.pending.length) return abort;\n    const item = {\n        id,\n        icons,\n        callback,\n        abort\n    };\n    pendingSources.forEach((storage)=>{\n        (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n    });\n    return abort;\n}\n/**\n* Check if icons have been loaded\n*/ function sortIcons(icons) {\n    const result = {\n        loaded: [],\n        missing: [],\n        pending: []\n    };\n    const storage = Object.create(null);\n    icons.sort((a, b)=>{\n        if (a.provider !== b.provider) return a.provider.localeCompare(b.provider);\n        if (a.prefix !== b.prefix) return a.prefix.localeCompare(b.prefix);\n        return a.name.localeCompare(b.name);\n    });\n    let lastIcon = {\n        provider: \"\",\n        prefix: \"\",\n        name: \"\"\n    };\n    icons.forEach((icon)=>{\n        if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) return;\n        lastIcon = icon;\n        const provider = icon.provider;\n        const prefix = icon.prefix;\n        const name = icon.name;\n        const providerStorage = storage[provider] || (storage[provider] = Object.create(null));\n        const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n        let list;\n        if (name in localStorage.icons) list = result.loaded;\n        else if (prefix === \"\" || localStorage.missing.has(name)) list = result.missing;\n        else list = result.pending;\n        const item = {\n            provider,\n            prefix,\n            name\n        };\n        list.push(item);\n    });\n    return result;\n}\n/**\n* Convert icons list from string/icon mix to icons and validate them\n*/ function listToIcons(list, validate = true, simpleNames = false) {\n    const result = [];\n    list.forEach((item)=>{\n        const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n        if (icon) result.push(icon);\n    });\n    return result;\n}\n/**\n* Default RedundancyConfig for API calls\n*/ const defaultConfig = {\n    resources: [],\n    index: 0,\n    timeout: 2e3,\n    rotate: 750,\n    random: false,\n    dataAfterTimeout: false\n};\n/**\n* Send query\n*/ function sendQuery(config, payload, query, done) {\n    const resourcesCount = config.resources.length;\n    const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n    let resources;\n    if (config.random) {\n        let list = config.resources.slice(0);\n        resources = [];\n        while(list.length > 1){\n            const nextIndex = Math.floor(Math.random() * list.length);\n            resources.push(list[nextIndex]);\n            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n        }\n        resources = resources.concat(list);\n    } else resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n    const startTime = Date.now();\n    let status = \"pending\";\n    let queriesSent = 0;\n    let lastError;\n    let timer = null;\n    let queue = [];\n    let doneCallbacks = [];\n    if (typeof done === \"function\") doneCallbacks.push(done);\n    /**\n\t* Reset timer\n\t*/ function resetTimer() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }\n    /**\n\t* Abort everything\n\t*/ function abort() {\n        if (status === \"pending\") status = \"aborted\";\n        resetTimer();\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") item.status = \"aborted\";\n        });\n        queue = [];\n    }\n    /**\n\t* Add / replace callback to call when execution is complete.\n\t* This can be used to abort pending query implementations when query is complete or aborted.\n\t*/ function subscribe(callback, overwrite) {\n        if (overwrite) doneCallbacks = [];\n        if (typeof callback === \"function\") doneCallbacks.push(callback);\n    }\n    /**\n\t* Get query status\n\t*/ function getQueryStatus() {\n        return {\n            startTime,\n            payload,\n            status,\n            queriesSent,\n            queriesPending: queue.length,\n            subscribe,\n            abort\n        };\n    }\n    /**\n\t* Fail query\n\t*/ function failQuery() {\n        status = \"failed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(void 0, lastError);\n        });\n    }\n    /**\n\t* Clear queue\n\t*/ function clearQueue() {\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") item.status = \"aborted\";\n        });\n        queue = [];\n    }\n    /**\n\t* Got response from module\n\t*/ function moduleResponse(item, response, data) {\n        const isError = response !== \"success\";\n        queue = queue.filter((queued)=>queued !== item);\n        switch(status){\n            case \"pending\":\n                break;\n            case \"failed\":\n                if (isError || !config.dataAfterTimeout) return;\n                break;\n            default:\n                return;\n        }\n        if (response === \"abort\") {\n            lastError = data;\n            failQuery();\n            return;\n        }\n        if (isError) {\n            lastError = data;\n            if (!queue.length) if (!resources.length) failQuery();\n            else execNext();\n            return;\n        }\n        resetTimer();\n        clearQueue();\n        if (!config.random) {\n            const index = config.resources.indexOf(item.resource);\n            if (index !== -1 && index !== config.index) config.index = index;\n        }\n        status = \"completed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(data);\n        });\n    }\n    /**\n\t* Execute next query\n\t*/ function execNext() {\n        if (status !== \"pending\") return;\n        resetTimer();\n        const resource = resources.shift();\n        if (resource === void 0) {\n            if (queue.length) {\n                timer = setTimeout(()=>{\n                    resetTimer();\n                    if (status === \"pending\") {\n                        clearQueue();\n                        failQuery();\n                    }\n                }, config.timeout);\n                return;\n            }\n            failQuery();\n            return;\n        }\n        const item = {\n            status: \"pending\",\n            resource,\n            callback: (status$1, data)=>{\n                moduleResponse(item, status$1, data);\n            }\n        };\n        queue.push(item);\n        queriesSent++;\n        timer = setTimeout(execNext, config.rotate);\n        query(resource, payload, item.callback);\n    }\n    setTimeout(execNext);\n    return getQueryStatus;\n}\n/**\n* Redundancy instance\n*/ function initRedundancy(cfg) {\n    const config = {\n        ...defaultConfig,\n        ...cfg\n    };\n    let queries = [];\n    /**\n\t* Remove aborted and completed queries\n\t*/ function cleanup() {\n        queries = queries.filter((item)=>item().status === \"pending\");\n    }\n    /**\n\t* Send query\n\t*/ function query(payload, queryCallback, doneCallback) {\n        const query$1 = sendQuery(config, payload, queryCallback, (data, error)=>{\n            cleanup();\n            if (doneCallback) doneCallback(data, error);\n        });\n        queries.push(query$1);\n        return query$1;\n    }\n    /**\n\t* Find instance\n\t*/ function find(callback) {\n        return queries.find((value)=>{\n            return callback(value);\n        }) || null;\n    }\n    const instance = {\n        query,\n        find,\n        setIndex: (index)=>{\n            config.index = index;\n        },\n        getIndex: ()=>config.index,\n        cleanup\n    };\n    return instance;\n}\nfunction emptyCallback$1() {}\nconst redundancyCache = Object.create(null);\n/**\n* Get Redundancy instance for provider\n*/ function getRedundancyCache(provider) {\n    if (!redundancyCache[provider]) {\n        const config = getAPIConfig(provider);\n        if (!config) return;\n        const redundancy = initRedundancy(config);\n        const cachedReundancy = {\n            config,\n            redundancy\n        };\n        redundancyCache[provider] = cachedReundancy;\n    }\n    return redundancyCache[provider];\n}\n/**\n* Send API query\n*/ function sendAPIQuery(target, query, callback) {\n    let redundancy;\n    let send;\n    if (typeof target === \"string\") {\n        const api = getAPIModule(target);\n        if (!api) {\n            callback(void 0, 424);\n            return emptyCallback$1;\n        }\n        send = api.send;\n        const cached = getRedundancyCache(target);\n        if (cached) redundancy = cached.redundancy;\n    } else {\n        const config = createAPIConfig(target);\n        if (config) {\n            redundancy = initRedundancy(config);\n            const moduleKey = target.resources ? target.resources[0] : \"\";\n            const api = getAPIModule(moduleKey);\n            if (api) send = api.send;\n        }\n    }\n    if (!redundancy || !send) {\n        callback(void 0, 424);\n        return emptyCallback$1;\n    }\n    return redundancy.query(query, send, callback)().abort;\n}\nfunction emptyCallback() {}\n/**\n* Function called when new icons have been loaded\n*/ function loadedNewIcons(storage) {\n    if (!storage.iconsLoaderFlag) {\n        storage.iconsLoaderFlag = true;\n        setTimeout(()=>{\n            storage.iconsLoaderFlag = false;\n            updateCallbacks(storage);\n        });\n    }\n}\n/**\n* Check icon names for API\n*/ function checkIconNamesForAPI(icons) {\n    const valid = [];\n    const invalid = [];\n    icons.forEach((name)=>{\n        (name.match(matchIconName) ? valid : invalid).push(name);\n    });\n    return {\n        valid,\n        invalid\n    };\n}\n/**\n* Parse loader response\n*/ function parseLoaderResponse(storage, icons, data) {\n    function checkMissing() {\n        const pending = storage.pendingIcons;\n        icons.forEach((name)=>{\n            if (pending) pending.delete(name);\n            if (!storage.icons[name]) storage.missing.add(name);\n        });\n    }\n    if (data && typeof data === \"object\") try {\n        const parsed = addIconSet(storage, data);\n        if (!parsed.length) {\n            checkMissing();\n            return;\n        }\n    } catch (err) {\n        console.error(err);\n    }\n    checkMissing();\n    loadedNewIcons(storage);\n}\n/**\n* Handle response that can be async\n*/ function parsePossiblyAsyncResponse(response, callback) {\n    if (response instanceof Promise) response.then((data)=>{\n        callback(data);\n    }).catch(()=>{\n        callback(null);\n    });\n    else callback(response);\n}\n/**\n* Load icons\n*/ function loadNewIcons(storage, icons) {\n    if (!storage.iconsToLoad) storage.iconsToLoad = icons;\n    else storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n    if (!storage.iconsQueueFlag) {\n        storage.iconsQueueFlag = true;\n        setTimeout(()=>{\n            storage.iconsQueueFlag = false;\n            const { provider, prefix } = storage;\n            const icons$1 = storage.iconsToLoad;\n            delete storage.iconsToLoad;\n            if (!icons$1 || !icons$1.length) return;\n            const customIconLoader = storage.loadIcon;\n            if (storage.loadIcons && (icons$1.length > 1 || !customIconLoader)) {\n                parsePossiblyAsyncResponse(storage.loadIcons(icons$1, prefix, provider), (data)=>{\n                    parseLoaderResponse(storage, icons$1, data);\n                });\n                return;\n            }\n            if (customIconLoader) {\n                icons$1.forEach((name)=>{\n                    const response = customIconLoader(name, prefix, provider);\n                    parsePossiblyAsyncResponse(response, (data)=>{\n                        const iconSet = data ? {\n                            prefix,\n                            icons: {\n                                [name]: data\n                            }\n                        } : null;\n                        parseLoaderResponse(storage, [\n                            name\n                        ], iconSet);\n                    });\n                });\n                return;\n            }\n            const { valid, invalid } = checkIconNamesForAPI(icons$1);\n            if (invalid.length) parseLoaderResponse(storage, invalid, null);\n            if (!valid.length) return;\n            const api = prefix.match(matchIconName) ? getAPIModule(provider) : null;\n            if (!api) {\n                parseLoaderResponse(storage, valid, null);\n                return;\n            }\n            const params = api.prepare(provider, prefix, valid);\n            params.forEach((item)=>{\n                sendAPIQuery(provider, item, (data)=>{\n                    parseLoaderResponse(storage, item.icons, data);\n                });\n            });\n        });\n    }\n}\n/**\n* Load icons\n*/ const loadIcons = (icons, callback)=>{\n    const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n    const sortedIcons = sortIcons(cleanedIcons);\n    if (!sortedIcons.pending.length) {\n        let callCallback = true;\n        if (callback) setTimeout(()=>{\n            if (callCallback) callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n        });\n        return ()=>{\n            callCallback = false;\n        };\n    }\n    const newIcons = Object.create(null);\n    const sources = [];\n    let lastProvider, lastPrefix;\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix } = icon;\n        if (prefix === lastPrefix && provider === lastProvider) return;\n        lastProvider = provider;\n        lastPrefix = prefix;\n        sources.push(getStorage(provider, prefix));\n        const providerNewIcons = newIcons[provider] || (newIcons[provider] = Object.create(null));\n        if (!providerNewIcons[prefix]) providerNewIcons[prefix] = [];\n    });\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix, name } = icon;\n        const storage = getStorage(provider, prefix);\n        const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n        if (!pendingQueue.has(name)) {\n            pendingQueue.add(name);\n            newIcons[provider][prefix].push(name);\n        }\n    });\n    sources.forEach((storage)=>{\n        const list = newIcons[storage.provider][storage.prefix];\n        if (list.length) loadNewIcons(storage, list);\n    });\n    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\n/**\n* Load one icon using Promise\n*/ const loadIcon = (icon)=>{\n    return new Promise((fulfill, reject)=>{\n        const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n        if (!iconObj) {\n            reject(icon);\n            return;\n        }\n        loadIcons([\n            iconObj || icon\n        ], (loaded)=>{\n            if (loaded.length && iconObj) {\n                const data = getIconData(iconObj);\n                if (data) {\n                    fulfill({\n                        ...defaultIconProps,\n                        ...data\n                    });\n                    return;\n                }\n            }\n            reject(icon);\n        });\n    });\n};\n/**\n* Set custom loader for multiple icons\n*/ function setCustomIconsLoader(loader, prefix, provider) {\n    getStorage(provider || \"\", prefix).loadIcons = loader;\n}\n/**\n* Set custom loader for one icon\n*/ function setCustomIconLoader(loader, prefix, provider) {\n    getStorage(provider || \"\", prefix).loadIcon = loader;\n}\n/**\n* Convert IconifyIconCustomisations to FullIconCustomisations, checking value types\n*/ function mergeCustomisations(defaults, item) {\n    const result = {\n        ...defaults\n    };\n    for(const key in item){\n        const value = item[key];\n        const valueType = typeof value;\n        if (key in defaultIconSizeCustomisations) {\n            if (value === null || value && (valueType === \"string\" || valueType === \"number\")) result[key] = value;\n        } else if (valueType === typeof result[key]) result[key] = key === \"rotate\" ? value % 4 : value;\n    }\n    return result;\n}\nconst separator = /[\\s,]+/;\n/**\n* Apply \"flip\" string to icon customisations\n*/ function flipFromString(custom, flip) {\n    flip.split(separator).forEach((str)=>{\n        const value = str.trim();\n        switch(value){\n            case \"horizontal\":\n                custom.hFlip = true;\n                break;\n            case \"vertical\":\n                custom.vFlip = true;\n                break;\n        }\n    });\n}\n/**\n* Get rotation value\n*/ function rotateFromString(value, defaultValue = 0) {\n    const units = value.replace(/^-?[0-9.]*/, \"\");\n    function cleanup(value$1) {\n        while(value$1 < 0)value$1 += 4;\n        return value$1 % 4;\n    }\n    if (units === \"\") {\n        const num = parseInt(value);\n        return isNaN(num) ? 0 : cleanup(num);\n    } else if (units !== value) {\n        let split = 0;\n        switch(units){\n            case \"%\":\n                split = 25;\n                break;\n            case \"deg\":\n                split = 90;\n        }\n        if (split) {\n            let num = parseFloat(value.slice(0, value.length - units.length));\n            if (isNaN(num)) return 0;\n            num = num / split;\n            return num % 1 === 0 ? cleanup(num) : 0;\n        }\n    }\n    return defaultValue;\n}\n/**\n* Generate <svg>\n*/ function iconToHTML(body, attributes) {\n    let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    for(const attr in attributes)renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\n/**\n* Encode SVG for use in url()\n*\n* Short alternative to encodeURIComponent() that encodes only stuff used in SVG, generating\n* smaller code.\n*/ function encodeSVGforURL(svg) {\n    return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\n/**\n* Generate data: URL from SVG\n*/ function svgToData(svg) {\n    return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\n/**\n* Generate url() from SVG\n*/ function svgToURL(svg) {\n    return 'url(\"' + svgToData(svg) + '\")';\n}\nlet policy;\n/**\n* Attempt to create policy\n*/ function createPolicy() {\n    try {\n        policy = window.trustedTypes.createPolicy(\"iconify\", {\n            createHTML: (s)=>s\n        });\n    } catch (err) {\n        policy = null;\n    }\n}\n/**\n* Clean up value for innerHTML assignment\n*\n* This code doesn't actually clean up anything.\n* It is intended be used with Iconify icon data, which has already been validated\n*/ function cleanUpInnerHTML(html) {\n    if (policy === void 0) createPolicy();\n    return policy ? policy.createHTML(html) : html;\n}\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false\n};\n/**\n * Default SVG attributes\n */ const svgDefaults = {\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"xmlnsXlink\": \"http://www.w3.org/1999/xlink\",\n    \"aria-hidden\": true,\n    \"role\": \"img\"\n};\n/**\n * Style modes\n */ const commonProps = {\n    display: \"inline-block\"\n};\nconst monotoneProps = {\n    backgroundColor: \"currentColor\"\n};\nconst coloredProps = {\n    backgroundColor: \"transparent\"\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    Image: \"var(--svg)\",\n    Repeat: \"no-repeat\",\n    Size: \"100% 100%\"\n};\nconst propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps\n};\nfor(const prefix in propsToAddTo){\n    const list = propsToAddTo[prefix];\n    for(const prop in propsToAdd){\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */ const inlineDefaults = {\n    ...defaultExtendedIconCustomisations,\n    inline: true\n};\n/**\n * Fix size: add 'px' to numbers\n */ function fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? \"px\" : \"\");\n}\n/**\n * Render icon\n */ const render = (// Icon must be validated before calling this function\nicon, // Partial properties\nprops, // Icon name\nname)=>{\n    // Get default properties\n    const defaultProps = props.inline ? inlineDefaults : defaultExtendedIconCustomisations;\n    // Get all customisations\n    const customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    const mode = props.mode || \"svg\";\n    // Create style\n    const style = {};\n    const customStyle = props.style || {};\n    // Create SVG component properties\n    const componentProps = {\n        ...mode === \"svg\" ? svgDefaults : {}\n    };\n    if (name) {\n        const iconName = stringToIcon(name, false, true);\n        if (iconName) {\n            const classNames = [\n                \"iconify\"\n            ];\n            const props = [\n                \"provider\",\n                \"prefix\"\n            ];\n            for (const prop of props){\n                if (iconName[prop]) {\n                    classNames.push(\"iconify--\" + iconName[prop]);\n                }\n            }\n            componentProps.className = classNames.join(\" \");\n        }\n    }\n    // Get element properties\n    for(let key in props){\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch(key){\n            // Properties to ignore\n            case \"icon\":\n            case \"style\":\n            case \"children\":\n            case \"onLoad\":\n            case \"mode\":\n            case \"ssr\":\n            case \"fallback\":\n                break;\n            // Forward ref\n            case \"_ref\":\n                componentProps.ref = value;\n                break;\n            // Merge class names\n            case \"className\":\n                componentProps[key] = (componentProps[key] ? componentProps[key] + \" \" : \"\") + value;\n                break;\n            // Boolean attributes\n            case \"inline\":\n            case \"hFlip\":\n            case \"vFlip\":\n                customisations[key] = value === true || value === \"true\" || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case \"flip\":\n                if (typeof value === \"string\") {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case \"color\":\n                style.color = value;\n                break;\n            // Rotation as string\n            case \"rotate\":\n                if (typeof value === \"string\") {\n                    customisations[key] = rotateFromString(value);\n                } else if (typeof value === \"number\") {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case \"ariaHidden\":\n            case \"aria-hidden\":\n                if (value !== true && value !== \"true\") {\n                    delete componentProps[\"aria-hidden\"];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = \"-0.125em\";\n    }\n    if (mode === \"svg\") {\n        // Add style\n        componentProps.style = {\n            ...style,\n            ...customStyle\n        };\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === \"string\") {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, \"_\");\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? ()=>id + \"ID\" + localCounter++ : \"iconifyReact\"))\n        };\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", componentProps);\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === \"mask\" || (mode === \"bg\" ? false : body.indexOf(\"currentColor\") !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + \"\",\n        height: height + \"\"\n    });\n    // Generate style\n    componentProps.style = {\n        ...style,\n        \"--svg\": svgToURL(html),\n        \"width\": fixSize(renderAttribs.width),\n        \"height\": fixSize(renderAttribs.height),\n        ...commonProps,\n        ...useMask ? monotoneProps : coloredProps,\n        ...customStyle\n    };\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", componentProps);\n};\n/**\n * Initialise stuff\n */ // Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule(\"\", fetchAPIModule);\n/**\n * Browser stuff\n */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\nfunction IconComponent(props) {\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!!props.ssr);\n    const [abort, setAbort] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Get initial state\n    function getInitialState(mounted) {\n        if (mounted) {\n            const name = props.icon;\n            if (typeof name === \"object\") {\n                // Icon as object\n                return {\n                    name: \"\",\n                    data: name\n                };\n            }\n            const data = getIconData(name);\n            if (data) {\n                return {\n                    name,\n                    data\n                };\n            }\n        }\n        return {\n            name: \"\"\n        };\n    }\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getInitialState(!!props.ssr));\n    // Cancel loading\n    function cleanup() {\n        const callback = abort.callback;\n        if (callback) {\n            callback();\n            setAbort({});\n        }\n    }\n    // Change state if it is different\n    function changeState(newState) {\n        if (JSON.stringify(state) !== JSON.stringify(newState)) {\n            cleanup();\n            setState(newState);\n            return true;\n        }\n    }\n    // Update state\n    function updateState() {\n        var _a;\n        const name = props.icon;\n        if (typeof name === \"object\") {\n            // Icon as object\n            changeState({\n                name: \"\",\n                data: name\n            });\n            return;\n        }\n        // New icon or got icon data\n        const data = getIconData(name);\n        if (changeState({\n            name,\n            data\n        })) {\n            if (data === undefined) {\n                // Load icon, update state when done\n                const callback = loadIcons([\n                    name\n                ], updateState);\n                setAbort({\n                    callback\n                });\n            } else if (data) {\n                // Icon data is available: trigger onLoad callback if present\n                (_a = props.onLoad) === null || _a === void 0 ? void 0 : _a.call(props, name);\n            }\n        }\n    }\n    // Mounted state, cleanup for loader\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setMounted(true);\n        return cleanup;\n    }, []);\n    // Icon changed or component mounted\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (mounted) {\n            updateState();\n        }\n    }, [\n        props.icon,\n        mounted\n    ]);\n    // Render icon\n    const { name, data } = state;\n    if (!data) {\n        return props.children ? props.children : props.fallback ? props.fallback : /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {});\n    }\n    return render({\n        ...defaultIconProps,\n        ...data\n    }, props, name);\n}\n/**\n * Block icon\n *\n * @param props - Component properties\n */ const Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>IconComponent({\n        ...props,\n        _ref: ref\n    }));\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */ const InlineIcon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>IconComponent({\n        inline: true,\n        ...props,\n        _ref: ref\n    }));\n/**\n * Internal API\n */ const _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGljb25pZnkvcmVhY3QvZGlzdC9pY29uaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJPQUV1RTtBQUV2RTs7OztBQUlBLEdBQ0EsU0FBU0ksYUFBYUMsSUFBSSxFQUFFQyxLQUFLO0lBQ2hDLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7SUFDeEIsTUFBTUMsVUFBVUgsS0FBS0csT0FBTyxJQUFJQyxPQUFPQyxNQUFNLENBQUM7SUFDOUMsTUFBTUMsV0FBV0YsT0FBT0MsTUFBTSxDQUFDO0lBQy9CLFNBQVNFLFFBQVFDLElBQUk7UUFDcEIsSUFBSU4sS0FBSyxDQUFDTSxLQUFLLEVBQUUsT0FBT0YsUUFBUSxDQUFDRSxLQUFLLEdBQUcsRUFBRTtRQUMzQyxJQUFJLENBQUVBLENBQUFBLFFBQVFGLFFBQU8sR0FBSTtZQUN4QkEsUUFBUSxDQUFDRSxLQUFLLEdBQUc7WUFDakIsTUFBTUMsU0FBU04sT0FBTyxDQUFDSyxLQUFLLElBQUlMLE9BQU8sQ0FBQ0ssS0FBSyxDQUFDQyxNQUFNO1lBQ3BELE1BQU1DLFFBQVFELFVBQVVGLFFBQVFFO1lBQ2hDLElBQUlDLE9BQU9KLFFBQVEsQ0FBQ0UsS0FBSyxHQUFHO2dCQUFDQzthQUFPLENBQUNFLE1BQU0sQ0FBQ0Q7UUFDN0M7UUFDQSxPQUFPSixRQUFRLENBQUNFLEtBQUs7SUFDdEI7SUFDQ0osT0FBT1EsSUFBSSxDQUFDVixPQUFPUyxNQUFNLENBQUNQLE9BQU9RLElBQUksQ0FBQ1QsVUFBV1UsT0FBTyxDQUFDTjtJQUMxRCxPQUFPRDtBQUNSO0FBRUE7O0FBRUEsR0FDQSxNQUFNUSx3QkFBd0JWLE9BQU9XLE1BQU0sQ0FBQztJQUMzQ0MsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLE9BQU87SUFDUEMsUUFBUTtBQUNUO0FBQ0E7O0FBRUEsR0FDQSxNQUFNQyw2QkFBNkJoQixPQUFPVyxNQUFNLENBQUM7SUFDaERNLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFP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LGlEQUFVQSxDQUFDLENBQUN5SSxPQUFPb1AsTUFBUWUsY0FBYztRQUN4RHhDLFFBQVE7UUFDUixHQUFHM04sS0FBSztRQUNSdVIsTUFBTW5DO0lBQ1Y7QUFDQTs7Q0FFQyxHQUNELE1BQU1xQyxPQUFPO0lBQ1Q1TztJQUNBZjtJQUNBdUg7SUFDQW5HO0lBQ0FFO0lBQ0FOO0FBQ0o7QUFFNk4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbmVjLXByZXMtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGljb25pZnkvcmVhY3QvZGlzdC9pY29uaWZ5LmpzPzEwOWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBmb3J3YXJkUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiogUmVzb2x2ZSBpY29uIHNldCBpY29uc1xuKlxuKiBSZXR1cm5zIHBhcmVudCBpY29uIGZvciBlYWNoIGljb25cbiovXG5mdW5jdGlvbiBnZXRJY29uc1RyZWUoZGF0YSwgbmFtZXMpIHtcblx0Y29uc3QgaWNvbnMgPSBkYXRhLmljb25zO1xuXHRjb25zdCBhbGlhc2VzID0gZGF0YS5hbGlhc2VzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGNvbnN0IHJlc29sdmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ZnVuY3Rpb24gcmVzb2x2ZShuYW1lKSB7XG5cdFx0aWYgKGljb25zW25hbWVdKSByZXR1cm4gcmVzb2x2ZWRbbmFtZV0gPSBbXTtcblx0XHRpZiAoIShuYW1lIGluIHJlc29sdmVkKSkge1xuXHRcdFx0cmVzb2x2ZWRbbmFtZV0gPSBudWxsO1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gYWxpYXNlc1tuYW1lXSAmJiBhbGlhc2VzW25hbWVdLnBhcmVudDtcblx0XHRcdGNvbnN0IHZhbHVlID0gcGFyZW50ICYmIHJlc29sdmUocGFyZW50KTtcblx0XHRcdGlmICh2YWx1ZSkgcmVzb2x2ZWRbbmFtZV0gPSBbcGFyZW50XS5jb25jYXQodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzb2x2ZWRbbmFtZV07XG5cdH1cblx0KE9iamVjdC5rZXlzKGljb25zKS5jb25jYXQoT2JqZWN0LmtleXMoYWxpYXNlcykpKS5mb3JFYWNoKHJlc29sdmUpO1xuXHRyZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbi8qKlxuKiBEZWZhdWx0IHZhbHVlcyBmb3IgZGltZW5zaW9uc1xuKi9cbmNvbnN0IGRlZmF1bHRJY29uRGltZW5zaW9ucyA9IE9iamVjdC5mcmVlemUoe1xuXHRsZWZ0OiAwLFxuXHR0b3A6IDAsXG5cdHdpZHRoOiAxNixcblx0aGVpZ2h0OiAxNlxufSk7XG4vKipcbiogRGVmYXVsdCB2YWx1ZXMgZm9yIHRyYW5zZm9ybWF0aW9uc1xuKi9cbmNvbnN0IGRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHJvdGF0ZTogMCxcblx0dkZsaXA6IGZhbHNlLFxuXHRoRmxpcDogZmFsc2Vcbn0pO1xuLyoqXG4qIERlZmF1bHQgdmFsdWVzIGZvciBhbGwgb3B0aW9uYWwgSWNvbmlmeUljb24gcHJvcGVydGllc1xuKi9cbmNvbnN0IGRlZmF1bHRJY29uUHJvcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Li4uZGVmYXVsdEljb25EaW1lbnNpb25zLFxuXHQuLi5kZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9uc1xufSk7XG4vKipcbiogRGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBwcm9wZXJ0aWVzIHVzZWQgaW4gRXh0ZW5kZWRJY29uaWZ5SWNvblxuKi9cbmNvbnN0IGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHQuLi5kZWZhdWx0SWNvblByb3BzLFxuXHRib2R5OiBcIlwiLFxuXHRoaWRkZW46IGZhbHNlXG59KTtcblxuLyoqXG4qIE1lcmdlIHRyYW5zZm9ybWF0aW9uc1xuKi9cbmZ1bmN0aW9uIG1lcmdlSWNvblRyYW5zZm9ybWF0aW9ucyhvYmoxLCBvYmoyKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRpZiAoIW9iajEuaEZsaXAgIT09ICFvYmoyLmhGbGlwKSByZXN1bHQuaEZsaXAgPSB0cnVlO1xuXHRpZiAoIW9iajEudkZsaXAgIT09ICFvYmoyLnZGbGlwKSByZXN1bHQudkZsaXAgPSB0cnVlO1xuXHRjb25zdCByb3RhdGUgPSAoKG9iajEucm90YXRlIHx8IDApICsgKG9iajIucm90YXRlIHx8IDApKSAlIDQ7XG5cdGlmIChyb3RhdGUpIHJlc3VsdC5yb3RhdGUgPSByb3RhdGU7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuKiBNZXJnZSBpY29uIGFuZCBhbGlhc1xuKlxuKiBDYW4gYWxzbyBiZSB1c2VkIHRvIG1lcmdlIGRlZmF1bHQgdmFsdWVzIGFuZCBpY29uXG4qL1xuZnVuY3Rpb24gbWVyZ2VJY29uRGF0YShwYXJlbnQsIGNoaWxkKSB7XG5cdGNvbnN0IHJlc3VsdCA9IG1lcmdlSWNvblRyYW5zZm9ybWF0aW9ucyhwYXJlbnQsIGNoaWxkKTtcblx0Zm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzKSBpZiAoa2V5IGluIGRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zKSB7XG5cdFx0aWYgKGtleSBpbiBwYXJlbnQgJiYgIShrZXkgaW4gcmVzdWx0KSkgcmVzdWx0W2tleV0gPSBkZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9uc1trZXldO1xuXHR9IGVsc2UgaWYgKGtleSBpbiBjaGlsZCkgcmVzdWx0W2tleV0gPSBjaGlsZFtrZXldO1xuXHRlbHNlIGlmIChrZXkgaW4gcGFyZW50KSByZXN1bHRba2V5XSA9IHBhcmVudFtrZXldO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiogR2V0IGljb24gZGF0YSwgdXNpbmcgcHJlcGFyZWQgYWxpYXNlcyB0cmVlXG4qL1xuZnVuY3Rpb24gaW50ZXJuYWxHZXRJY29uRGF0YShkYXRhLCBuYW1lLCB0cmVlKSB7XG5cdGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcblx0Y29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRsZXQgY3VycmVudFByb3BzID0ge307XG5cdGZ1bmN0aW9uIHBhcnNlKG5hbWUkMSkge1xuXHRcdGN1cnJlbnRQcm9wcyA9IG1lcmdlSWNvbkRhdGEoaWNvbnNbbmFtZSQxXSB8fCBhbGlhc2VzW25hbWUkMV0sIGN1cnJlbnRQcm9wcyk7XG5cdH1cblx0cGFyc2UobmFtZSk7XG5cdHRyZWUuZm9yRWFjaChwYXJzZSk7XG5cdHJldHVybiBtZXJnZUljb25EYXRhKGRhdGEsIGN1cnJlbnRQcm9wcyk7XG59XG5cbi8qKlxuKiBFeHRyYWN0IGljb25zIGZyb20gYW4gaWNvbiBzZXRcbipcbiogUmV0dXJucyBsaXN0IG9mIGljb25zIHRoYXQgd2VyZSBmb3VuZCBpbiBpY29uIHNldFxuKi9cbmZ1bmN0aW9uIHBhcnNlSWNvblNldChkYXRhLCBjYWxsYmFjaykge1xuXHRjb25zdCBuYW1lcyA9IFtdO1xuXHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGRhdGEuaWNvbnMgIT09IFwib2JqZWN0XCIpIHJldHVybiBuYW1lcztcblx0aWYgKGRhdGEubm90X2ZvdW5kIGluc3RhbmNlb2YgQXJyYXkpIGRhdGEubm90X2ZvdW5kLmZvckVhY2goKG5hbWUpID0+IHtcblx0XHRjYWxsYmFjayhuYW1lLCBudWxsKTtcblx0XHRuYW1lcy5wdXNoKG5hbWUpO1xuXHR9KTtcblx0Y29uc3QgdHJlZSA9IGdldEljb25zVHJlZShkYXRhKTtcblx0Zm9yIChjb25zdCBuYW1lIGluIHRyZWUpIHtcblx0XHRjb25zdCBpdGVtID0gdHJlZVtuYW1lXTtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0Y2FsbGJhY2sobmFtZSwgaW50ZXJuYWxHZXRJY29uRGF0YShkYXRhLCBuYW1lLCBpdGVtKSk7XG5cdFx0XHRuYW1lcy5wdXNoKG5hbWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbmFtZXM7XG59XG5cbi8qKlxuKiBPcHRpb25hbCBwcm9wZXJ0aWVzXG4qL1xuY29uc3Qgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzID0ge1xuXHRwcm92aWRlcjogXCJcIixcblx0YWxpYXNlczoge30sXG5cdG5vdF9mb3VuZDoge30sXG5cdC4uLmRlZmF1bHRJY29uRGltZW5zaW9uc1xufTtcbi8qKlxuKiBDaGVjayBwcm9wc1xuKi9cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uYWxQcm9wcyhpdGVtLCBkZWZhdWx0cykge1xuXHRmb3IgKGNvbnN0IHByb3AgaW4gZGVmYXVsdHMpIGlmIChwcm9wIGluIGl0ZW0gJiYgdHlwZW9mIGl0ZW1bcHJvcF0gIT09IHR5cGVvZiBkZWZhdWx0c1twcm9wXSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuKiBWYWxpZGF0ZSBpY29uIHNldCwgcmV0dXJuIGl0IGFzIEljb25pZnlKU09OIG9uIHN1Y2Nlc3MsIG51bGwgb24gZmFpbHVyZVxuKlxuKiBVbmxpa2UgdmFsaWRhdGVJY29uU2V0KCksIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBiYXNpYy5cbiogSXQgZG9lcyBub3QgdGhyb3cgZXhjZXB0aW9ucywgaXQgZG9lcyBub3QgY2hlY2sgbWV0YWRhdGEsIGl0IGRvZXMgbm90IGZpeCBzdHVmZi5cbiovXG5mdW5jdGlvbiBxdWlja2x5VmFsaWRhdGVJY29uU2V0KG9iaikge1xuXHRpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHJldHVybiBudWxsO1xuXHRjb25zdCBkYXRhID0gb2JqO1xuXHRpZiAodHlwZW9mIGRhdGEucHJlZml4ICE9PSBcInN0cmluZ1wiIHx8ICFvYmouaWNvbnMgfHwgdHlwZW9mIG9iai5pY29ucyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIG51bGw7XG5cdGlmICghY2hlY2tPcHRpb25hbFByb3BzKG9iaiwgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzKSkgcmV0dXJuIG51bGw7XG5cdGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcblx0Zm9yIChjb25zdCBuYW1lIGluIGljb25zKSB7XG5cdFx0Y29uc3QgaWNvbiA9IGljb25zW25hbWVdO1xuXHRcdGlmICghbmFtZSB8fCB0eXBlb2YgaWNvbi5ib2R5ICE9PSBcInN0cmluZ1wiIHx8ICFjaGVja09wdGlvbmFsUHJvcHMoaWNvbiwgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzKSkgcmV0dXJuIG51bGw7XG5cdH1cblx0Y29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRmb3IgKGNvbnN0IG5hbWUgaW4gYWxpYXNlcykge1xuXHRcdGNvbnN0IGljb24gPSBhbGlhc2VzW25hbWVdO1xuXHRcdGNvbnN0IHBhcmVudCA9IGljb24ucGFyZW50O1xuXHRcdGlmICghbmFtZSB8fCB0eXBlb2YgcGFyZW50ICE9PSBcInN0cmluZ1wiIHx8ICFpY29uc1twYXJlbnRdICYmICFhbGlhc2VzW3BhcmVudF0gfHwgIWNoZWNrT3B0aW9uYWxQcm9wcyhpY29uLCBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMpKSByZXR1cm4gbnVsbDtcblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4qIFN0b3JhZ2UgYnkgcHJvdmlkZXIgYW5kIHByZWZpeFxuKi9cbmNvbnN0IGRhdGFTdG9yYWdlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuKiBDcmVhdGUgbmV3IHN0b3JhZ2VcbiovXG5mdW5jdGlvbiBuZXdTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpIHtcblx0cmV0dXJuIHtcblx0XHRwcm92aWRlcixcblx0XHRwcmVmaXgsXG5cdFx0aWNvbnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cdFx0bWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuXHR9O1xufVxuLyoqXG4qIEdldCBzdG9yYWdlIGZvciBwcm92aWRlciBhbmQgcHJlZml4XG4qL1xuZnVuY3Rpb24gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSB7XG5cdGNvbnN0IHByb3ZpZGVyU3RvcmFnZSA9IGRhdGFTdG9yYWdlW3Byb3ZpZGVyXSB8fCAoZGF0YVN0b3JhZ2VbcHJvdmlkZXJdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdHJldHVybiBwcm92aWRlclN0b3JhZ2VbcHJlZml4XSB8fCAocHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gPSBuZXdTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpKTtcbn1cbi8qKlxuKiBBZGQgaWNvbiBzZXQgdG8gc3RvcmFnZVxuKlxuKiBSZXR1cm5zIGFycmF5IG9mIGFkZGVkIGljb25zXG4qL1xuZnVuY3Rpb24gYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKSB7XG5cdGlmICghcXVpY2tseVZhbGlkYXRlSWNvblNldChkYXRhKSkgcmV0dXJuIFtdO1xuXHRyZXR1cm4gcGFyc2VJY29uU2V0KGRhdGEsIChuYW1lLCBpY29uKSA9PiB7XG5cdFx0aWYgKGljb24pIHN0b3JhZ2UuaWNvbnNbbmFtZV0gPSBpY29uO1xuXHRcdGVsc2Ugc3RvcmFnZS5taXNzaW5nLmFkZChuYW1lKTtcblx0fSk7XG59XG4vKipcbiogQWRkIGljb24gdG8gc3RvcmFnZVxuKi9cbmZ1bmN0aW9uIGFkZEljb25Ub1N0b3JhZ2Uoc3RvcmFnZSwgbmFtZSwgaWNvbikge1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgaWNvbi5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRzdG9yYWdlLmljb25zW25hbWVdID0geyAuLi5pY29uIH07XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge31cblx0cmV0dXJuIGZhbHNlO1xufVxuLyoqXG4qIExpc3QgYXZhaWxhYmxlIGljb25zXG4qL1xuZnVuY3Rpb24gbGlzdEljb25zKHByb3ZpZGVyLCBwcmVmaXgpIHtcblx0bGV0IGFsbEljb25zID0gW107XG5cdGNvbnN0IHByb3ZpZGVycyA9IHR5cGVvZiBwcm92aWRlciA9PT0gXCJzdHJpbmdcIiA/IFtwcm92aWRlcl0gOiBPYmplY3Qua2V5cyhkYXRhU3RvcmFnZSk7XG5cdHByb3ZpZGVycy5mb3JFYWNoKChwcm92aWRlciQxKSA9PiB7XG5cdFx0Y29uc3QgcHJlZml4ZXMgPSB0eXBlb2YgcHJvdmlkZXIkMSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcHJlZml4ID09PSBcInN0cmluZ1wiID8gW3ByZWZpeF0gOiBPYmplY3Qua2V5cyhkYXRhU3RvcmFnZVtwcm92aWRlciQxXSB8fCB7fSk7XG5cdFx0cHJlZml4ZXMuZm9yRWFjaCgocHJlZml4JDEpID0+IHtcblx0XHRcdGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyJDEsIHByZWZpeCQxKTtcblx0XHRcdGFsbEljb25zID0gYWxsSWNvbnMuY29uY2F0KE9iamVjdC5rZXlzKHN0b3JhZ2UuaWNvbnMpLm1hcCgobmFtZSkgPT4gKHByb3ZpZGVyJDEgIT09IFwiXCIgPyBcIkBcIiArIHByb3ZpZGVyJDEgKyBcIjpcIiA6IFwiXCIpICsgcHJlZml4JDEgKyBcIjpcIiArIG5hbWUpKTtcblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBhbGxJY29ucztcbn1cblxuLyoqXG4qIEV4cHJlc3Npb24gdG8gdGVzdCBwYXJ0IG9mIGljb24gbmFtZS5cbipcbiogVXNlZCB3aGVuIGxvYWRpbmcgaWNvbnMgZnJvbSBJY29uaWZ5IEFQSSBkdWUgdG8gcHJvamVjdCBuYW1pbmcgY29udmVuc2lvbi5cbiogSWdub3JlZCB3aGVuIHVzaW5nIGN1c3RvbSBpY29uIHNldHMgLSBjb252ZW5zaW9uIGRvZXMgbm90IGFwcGx5LlxuKi9cbmNvbnN0IG1hdGNoSWNvbk5hbWUgPSAvXlthLXowLTldKygtW2EtejAtOV0rKSokLztcbi8qKlxuKiBDb252ZXJ0IHN0cmluZyBpY29uIG5hbWUgdG8gSWNvbmlmeUljb25OYW1lIG9iamVjdC5cbiovXG5jb25zdCBzdHJpbmdUb0ljb24gPSAodmFsdWUsIHZhbGlkYXRlLCBhbGxvd1NpbXBsZU5hbWUsIHByb3ZpZGVyID0gXCJcIikgPT4ge1xuXHRjb25zdCBjb2xvblNlcGFyYXRlZCA9IHZhbHVlLnNwbGl0KFwiOlwiKTtcblx0aWYgKHZhbHVlLnNsaWNlKDAsIDEpID09PSBcIkBcIikge1xuXHRcdGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPCAyIHx8IGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDMpIHJldHVybiBudWxsO1xuXHRcdHByb3ZpZGVyID0gY29sb25TZXBhcmF0ZWQuc2hpZnQoKS5zbGljZSgxKTtcblx0fVxuXHRpZiAoY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMyB8fCAhY29sb25TZXBhcmF0ZWQubGVuZ3RoKSByZXR1cm4gbnVsbDtcblx0aWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDEpIHtcblx0XHRjb25zdCBuYW1lJDEgPSBjb2xvblNlcGFyYXRlZC5wb3AoKTtcblx0XHRjb25zdCBwcmVmaXggPSBjb2xvblNlcGFyYXRlZC5wb3AoKTtcblx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRwcm92aWRlcjogY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMCA/IGNvbG9uU2VwYXJhdGVkWzBdIDogcHJvdmlkZXIsXG5cdFx0XHRwcmVmaXgsXG5cdFx0XHRuYW1lOiBuYW1lJDFcblx0XHR9O1xuXHRcdHJldHVybiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGVJY29uTmFtZShyZXN1bHQpID8gbnVsbCA6IHJlc3VsdDtcblx0fVxuXHRjb25zdCBuYW1lID0gY29sb25TZXBhcmF0ZWRbMF07XG5cdGNvbnN0IGRhc2hTZXBhcmF0ZWQgPSBuYW1lLnNwbGl0KFwiLVwiKTtcblx0aWYgKGRhc2hTZXBhcmF0ZWQubGVuZ3RoID4gMSkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHtcblx0XHRcdHByb3ZpZGVyLFxuXHRcdFx0cHJlZml4OiBkYXNoU2VwYXJhdGVkLnNoaWZ0KCksXG5cdFx0XHRuYW1lOiBkYXNoU2VwYXJhdGVkLmpvaW4oXCItXCIpXG5cdFx0fTtcblx0XHRyZXR1cm4gdmFsaWRhdGUgJiYgIXZhbGlkYXRlSWNvbk5hbWUocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG5cdH1cblx0aWYgKGFsbG93U2ltcGxlTmFtZSAmJiBwcm92aWRlciA9PT0gXCJcIikge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHtcblx0XHRcdHByb3ZpZGVyLFxuXHRcdFx0cHJlZml4OiBcIlwiLFxuXHRcdFx0bmFtZVxuXHRcdH07XG5cdFx0cmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb25OYW1lKHJlc3VsdCwgYWxsb3dTaW1wbGVOYW1lKSA/IG51bGwgOiByZXN1bHQ7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuLyoqXG4qIENoZWNrIGlmIGljb24gaXMgdmFsaWQuXG4qXG4qIFRoaXMgZnVuY3Rpb24gaXMgbm90IHBhcnQgb2Ygc3RyaW5nVG9JY29uIGJlY2F1c2UgdmFsaWRhdGlvbiBpcyBub3QgbmVlZGVkIGZvciBtb3N0IGNvZGUuXG4qL1xuY29uc3QgdmFsaWRhdGVJY29uTmFtZSA9IChpY29uLCBhbGxvd1NpbXBsZU5hbWUpID0+IHtcblx0aWYgKCFpY29uKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAhISgoYWxsb3dTaW1wbGVOYW1lICYmIGljb24ucHJlZml4ID09PSBcIlwiIHx8ICEhaWNvbi5wcmVmaXgpICYmICEhaWNvbi5uYW1lKTtcbn07XG5cbi8qKlxuKiBBbGxvdyBzdG9yaW5nIGljb25zIHdpdGhvdXQgcHJvdmlkZXIgb3IgcHJlZml4LCBtYWtpbmcgaXQgcG9zc2libGUgdG8gc3RvcmUgaWNvbnMgbGlrZSBcImhvbWVcIlxuKi9cbmxldCBzaW1wbGVOYW1lcyA9IGZhbHNlO1xuZnVuY3Rpb24gYWxsb3dTaW1wbGVOYW1lcyhhbGxvdykge1xuXHRpZiAodHlwZW9mIGFsbG93ID09PSBcImJvb2xlYW5cIikgc2ltcGxlTmFtZXMgPSBhbGxvdztcblx0cmV0dXJuIHNpbXBsZU5hbWVzO1xufVxuLyoqXG4qIEdldCBpY29uIGRhdGFcbipcbiogUmV0dXJuczpcbiogLSBJY29uaWZ5SWNvbiBvbiBzdWNjZXNzLCBvYmplY3QgZGlyZWN0bHkgZnJvbSBzdG9yYWdlIHNvIGRvbid0IG1vZGlmeSBpdFxuKiAtIG51bGwgaWYgaWNvbiBpcyBtYXJrZWQgYXMgbWlzc2luZyAocmV0dXJuZWQgaW4gYG5vdF9mb3VuZGAgcHJvcGVydHkgZnJvbSBBUEksIHNvIGRvbid0IGJvdGhlciBzZW5kaW5nIEFQSSByZXF1ZXN0cylcbiogLSB1bmRlZmluZWQgaWYgaWNvbiBpcyBtaXNzaW5nIGluIHN0b3JhZ2VcbiovXG5mdW5jdGlvbiBnZXRJY29uRGF0YShuYW1lKSB7XG5cdGNvbnN0IGljb24gPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZ1RvSWNvbihuYW1lLCB0cnVlLCBzaW1wbGVOYW1lcykgOiBuYW1lO1xuXHRpZiAoaWNvbikge1xuXHRcdGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKGljb24ucHJvdmlkZXIsIGljb24ucHJlZml4KTtcblx0XHRjb25zdCBpY29uTmFtZSA9IGljb24ubmFtZTtcblx0XHRyZXR1cm4gc3RvcmFnZS5pY29uc1tpY29uTmFtZV0gfHwgKHN0b3JhZ2UubWlzc2luZy5oYXMoaWNvbk5hbWUpID8gbnVsbCA6IHZvaWQgMCk7XG5cdH1cbn1cbi8qKlxuKiBBZGQgb25lIGljb25cbiovXG5mdW5jdGlvbiBhZGRJY29uKG5hbWUsIGRhdGEpIHtcblx0Y29uc3QgaWNvbiA9IHN0cmluZ1RvSWNvbihuYW1lLCB0cnVlLCBzaW1wbGVOYW1lcyk7XG5cdGlmICghaWNvbikgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShpY29uLnByb3ZpZGVyLCBpY29uLnByZWZpeCk7XG5cdGlmIChkYXRhKSByZXR1cm4gYWRkSWNvblRvU3RvcmFnZShzdG9yYWdlLCBpY29uLm5hbWUsIGRhdGEpO1xuXHRlbHNlIHtcblx0XHRzdG9yYWdlLm1pc3NpbmcuYWRkKGljb24ubmFtZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cbi8qKlxuKiBBZGQgaWNvbiBzZXRcbiovXG5mdW5jdGlvbiBhZGRDb2xsZWN0aW9uKGRhdGEsIHByb3ZpZGVyKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHByb3ZpZGVyICE9PSBcInN0cmluZ1wiKSBwcm92aWRlciA9IGRhdGEucHJvdmlkZXIgfHwgXCJcIjtcblx0aWYgKHNpbXBsZU5hbWVzICYmICFwcm92aWRlciAmJiAhZGF0YS5wcmVmaXgpIHtcblx0XHRsZXQgYWRkZWQgPSBmYWxzZTtcblx0XHRpZiAocXVpY2tseVZhbGlkYXRlSWNvblNldChkYXRhKSkge1xuXHRcdFx0ZGF0YS5wcmVmaXggPSBcIlwiO1xuXHRcdFx0cGFyc2VJY29uU2V0KGRhdGEsIChuYW1lLCBpY29uKSA9PiB7XG5cdFx0XHRcdGlmIChhZGRJY29uKG5hbWUsIGljb24pKSBhZGRlZCA9IHRydWU7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFkZGVkO1xuXHR9XG5cdGNvbnN0IHByZWZpeCA9IGRhdGEucHJlZml4O1xuXHRpZiAoIXZhbGlkYXRlSWNvbk5hbWUoe1xuXHRcdHByZWZpeCxcblx0XHRuYW1lOiBcImFcIlxuXHR9KSkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcblx0cmV0dXJuICEhYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKTtcbn1cbi8qKlxuKiBDaGVjayBpZiBpY29uIGRhdGEgaXMgYXZhaWxhYmxlXG4qL1xuZnVuY3Rpb24gaWNvbkxvYWRlZChuYW1lKSB7XG5cdHJldHVybiAhIWdldEljb25EYXRhKG5hbWUpO1xufVxuLyoqXG4qIEdldCBmdWxsIGljb25cbiovXG5mdW5jdGlvbiBnZXRJY29uKG5hbWUpIHtcblx0Y29uc3QgcmVzdWx0ID0gZ2V0SWNvbkRhdGEobmFtZSk7XG5cdHJldHVybiByZXN1bHQgPyB7XG5cdFx0Li4uZGVmYXVsdEljb25Qcm9wcyxcblx0XHQuLi5yZXN1bHRcblx0fSA6IHJlc3VsdDtcbn1cblxuLyoqXG4qIERlZmF1bHQgaWNvbiBjdXN0b21pc2F0aW9ucyB2YWx1ZXNcbiovXG5jb25zdCBkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuXHR3aWR0aDogbnVsbCxcblx0aGVpZ2h0OiBudWxsXG59KTtcbmNvbnN0IGRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcblx0Li4uZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMsXG5cdC4uLmRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zXG59KTtcblxuLyoqXG4qIFJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIGNhbGN1bGF0aW5nIGRpbWVuc2lvbnNcbiovXG5jb25zdCB1bml0c1NwbGl0ID0gLygtP1swLTkuXSpbMC05XStbMC05Ll0qKS9nO1xuY29uc3QgdW5pdHNUZXN0ID0gL14tP1swLTkuXSpbMC05XStbMC05Ll0qJC9nO1xuZnVuY3Rpb24gY2FsY3VsYXRlU2l6ZShzaXplLCByYXRpbywgcHJlY2lzaW9uKSB7XG5cdGlmIChyYXRpbyA9PT0gMSkgcmV0dXJuIHNpemU7XG5cdHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAxMDA7XG5cdGlmICh0eXBlb2Ygc2l6ZSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIE1hdGguY2VpbChzaXplICogcmF0aW8gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXHRpZiAodHlwZW9mIHNpemUgIT09IFwic3RyaW5nXCIpIHJldHVybiBzaXplO1xuXHRjb25zdCBvbGRQYXJ0cyA9IHNpemUuc3BsaXQodW5pdHNTcGxpdCk7XG5cdGlmIChvbGRQYXJ0cyA9PT0gbnVsbCB8fCAhb2xkUGFydHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcblx0Y29uc3QgbmV3UGFydHMgPSBbXTtcblx0bGV0IGNvZGUgPSBvbGRQYXJ0cy5zaGlmdCgpO1xuXHRsZXQgaXNOdW1iZXIgPSB1bml0c1Rlc3QudGVzdChjb2RlKTtcblx0d2hpbGUgKHRydWUpIHtcblx0XHRpZiAoaXNOdW1iZXIpIHtcblx0XHRcdGNvbnN0IG51bSA9IHBhcnNlRmxvYXQoY29kZSk7XG5cdFx0XHRpZiAoaXNOYU4obnVtKSkgbmV3UGFydHMucHVzaChjb2RlKTtcblx0XHRcdGVsc2UgbmV3UGFydHMucHVzaChNYXRoLmNlaWwobnVtICogcmF0aW8gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTtcblx0XHR9IGVsc2UgbmV3UGFydHMucHVzaChjb2RlKTtcblx0XHRjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcblx0XHRpZiAoY29kZSA9PT0gdm9pZCAwKSByZXR1cm4gbmV3UGFydHMuam9pbihcIlwiKTtcblx0XHRpc051bWJlciA9ICFpc051bWJlcjtcblx0fVxufVxuXG5mdW5jdGlvbiBzcGxpdFNWR0RlZnMoY29udGVudCwgdGFnID0gXCJkZWZzXCIpIHtcblx0bGV0IGRlZnMgPSBcIlwiO1xuXHRjb25zdCBpbmRleCA9IGNvbnRlbnQuaW5kZXhPZihcIjxcIiArIHRhZyk7XG5cdHdoaWxlIChpbmRleCA+PSAwKSB7XG5cdFx0Y29uc3Qgc3RhcnQgPSBjb250ZW50LmluZGV4T2YoXCI+XCIsIGluZGV4KTtcblx0XHRjb25zdCBlbmQgPSBjb250ZW50LmluZGV4T2YoXCI8L1wiICsgdGFnKTtcblx0XHRpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIGJyZWFrO1xuXHRcdGNvbnN0IGVuZEVuZCA9IGNvbnRlbnQuaW5kZXhPZihcIj5cIiwgZW5kKTtcblx0XHRpZiAoZW5kRW5kID09PSAtMSkgYnJlYWs7XG5cdFx0ZGVmcyArPSBjb250ZW50LnNsaWNlKHN0YXJ0ICsgMSwgZW5kKS50cmltKCk7XG5cdFx0Y29udGVudCA9IGNvbnRlbnQuc2xpY2UoMCwgaW5kZXgpLnRyaW0oKSArIGNvbnRlbnQuc2xpY2UoZW5kRW5kICsgMSk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRkZWZzLFxuXHRcdGNvbnRlbnRcblx0fTtcbn1cbi8qKlxuKiBNZXJnZSBkZWZzIGFuZCBjb250ZW50XG4qL1xuZnVuY3Rpb24gbWVyZ2VEZWZzQW5kQ29udGVudChkZWZzLCBjb250ZW50KSB7XG5cdHJldHVybiBkZWZzID8gXCI8ZGVmcz5cIiArIGRlZnMgKyBcIjwvZGVmcz5cIiArIGNvbnRlbnQgOiBjb250ZW50O1xufVxuLyoqXG4qIFdyYXAgU1ZHIGNvbnRlbnQsIHdpdGhvdXQgd3JhcHBpbmcgZGVmaW5pdGlvbnNcbiovXG5mdW5jdGlvbiB3cmFwU1ZHQ29udGVudChib2R5LCBzdGFydCwgZW5kKSB7XG5cdGNvbnN0IHNwbGl0ID0gc3BsaXRTVkdEZWZzKGJvZHkpO1xuXHRyZXR1cm4gbWVyZ2VEZWZzQW5kQ29udGVudChzcGxpdC5kZWZzLCBzdGFydCArIHNwbGl0LmNvbnRlbnQgKyBlbmQpO1xufVxuXG4vKipcbiogQ2hlY2sgaWYgdmFsdWUgc2hvdWxkIGJlIHVuc2V0LiBBbGxvd3MgbXVsdGlwbGUga2V5d29yZHNcbiovXG5jb25zdCBpc1Vuc2V0S2V5d29yZCA9ICh2YWx1ZSkgPT4gdmFsdWUgPT09IFwidW5zZXRcIiB8fCB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWx1ZSA9PT0gXCJub25lXCI7XG4vKipcbiogR2V0IFNWRyBhdHRyaWJ1dGVzIGFuZCBjb250ZW50IGZyb20gaWNvbiArIGN1c3RvbWlzYXRpb25zXG4qXG4qIERvZXMgbm90IGdlbmVyYXRlIHN0eWxlIHRvIG1ha2UgaXQgY29tcGF0aWJsZSB3aXRoIGZyYW1ld29ya3MgdGhhdCB1c2Ugb2JqZWN0cyBmb3Igc3R5bGUsIHN1Y2ggYXMgUmVhY3QuXG4qIEluc3RlYWQsIGl0IGdlbmVyYXRlcyAnaW5saW5lJyB2YWx1ZS4gSWYgdHJ1ZSwgcmVuZGVyaW5nIGVuZ2luZSBzaG91bGQgYWRkIHZlcnRpY2FsQWxpZ246IC0wLjEyNWVtIHRvIGljb24uXG4qXG4qIEN1c3RvbWlzYXRpb25zIHNob3VsZCBiZSBub3JtYWxpc2VkIGJ5IHBsYXRmb3JtIHNwZWNpZmljIHBhcnNlci5cbiogUmVzdWx0IHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gPHN2Zz4gYnkgcGxhdGZvcm0gc3BlY2lmaWMgcGFyc2VyLlxuKiBVc2UgcmVwbGFjZUlEcyB0byBnZW5lcmF0ZSB1bmlxdWUgSURzIGZvciBib2R5LlxuKi9cbmZ1bmN0aW9uIGljb25Ub1NWRyhpY29uLCBjdXN0b21pc2F0aW9ucykge1xuXHRjb25zdCBmdWxsSWNvbiA9IHtcblx0XHQuLi5kZWZhdWx0SWNvblByb3BzLFxuXHRcdC4uLmljb25cblx0fTtcblx0Y29uc3QgZnVsbEN1c3RvbWlzYXRpb25zID0ge1xuXHRcdC4uLmRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMsXG5cdFx0Li4uY3VzdG9taXNhdGlvbnNcblx0fTtcblx0Y29uc3QgYm94ID0ge1xuXHRcdGxlZnQ6IGZ1bGxJY29uLmxlZnQsXG5cdFx0dG9wOiBmdWxsSWNvbi50b3AsXG5cdFx0d2lkdGg6IGZ1bGxJY29uLndpZHRoLFxuXHRcdGhlaWdodDogZnVsbEljb24uaGVpZ2h0XG5cdH07XG5cdGxldCBib2R5ID0gZnVsbEljb24uYm9keTtcblx0W2Z1bGxJY29uLCBmdWxsQ3VzdG9taXNhdGlvbnNdLmZvckVhY2goKHByb3BzKSA9PiB7XG5cdFx0Y29uc3QgdHJhbnNmb3JtYXRpb25zID0gW107XG5cdFx0Y29uc3QgaEZsaXAgPSBwcm9wcy5oRmxpcDtcblx0XHRjb25zdCB2RmxpcCA9IHByb3BzLnZGbGlwO1xuXHRcdGxldCByb3RhdGlvbiA9IHByb3BzLnJvdGF0ZTtcblx0XHRpZiAoaEZsaXApIGlmICh2RmxpcCkgcm90YXRpb24gKz0gMjtcblx0XHRlbHNlIHtcblx0XHRcdHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwidHJhbnNsYXRlKFwiICsgKGJveC53aWR0aCArIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoMCAtIGJveC50b3ApLnRvU3RyaW5nKCkgKyBcIilcIik7XG5cdFx0XHR0cmFuc2Zvcm1hdGlvbnMucHVzaChcInNjYWxlKC0xIDEpXCIpO1xuXHRcdFx0Ym94LnRvcCA9IGJveC5sZWZ0ID0gMDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodkZsaXApIHtcblx0XHRcdHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwidHJhbnNsYXRlKFwiICsgKDAgLSBib3gubGVmdCkudG9TdHJpbmcoKSArIFwiIFwiICsgKGJveC5oZWlnaHQgKyBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCIpO1xuXHRcdFx0dHJhbnNmb3JtYXRpb25zLnB1c2goXCJzY2FsZSgxIC0xKVwiKTtcblx0XHRcdGJveC50b3AgPSBib3gubGVmdCA9IDA7XG5cdFx0fVxuXHRcdGxldCB0ZW1wVmFsdWU7XG5cdFx0aWYgKHJvdGF0aW9uIDwgMCkgcm90YXRpb24gLT0gTWF0aC5mbG9vcihyb3RhdGlvbiAvIDQpICogNDtcblx0XHRyb3RhdGlvbiA9IHJvdGF0aW9uICUgNDtcblx0XHRzd2l0Y2ggKHJvdGF0aW9uKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXBWYWx1ZSA9IGJveC5oZWlnaHQgLyAyICsgYm94LnRvcDtcblx0XHRcdFx0dHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXCJyb3RhdGUoOTAgXCIgKyB0ZW1wVmFsdWUudG9TdHJpbmcoKSArIFwiIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIilcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcInJvdGF0ZSgxODAgXCIgKyAoYm94LndpZHRoIC8gMiArIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCAvIDIgKyBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMzpcblx0XHRcdFx0dGVtcFZhbHVlID0gYm94LndpZHRoIC8gMiArIGJveC5sZWZ0O1xuXHRcdFx0XHR0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcInJvdGF0ZSgtOTAgXCIgKyB0ZW1wVmFsdWUudG9TdHJpbmcoKSArIFwiIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIilcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAocm90YXRpb24gJSAyID09PSAxKSB7XG5cdFx0XHRpZiAoYm94LmxlZnQgIT09IGJveC50b3ApIHtcblx0XHRcdFx0dGVtcFZhbHVlID0gYm94LmxlZnQ7XG5cdFx0XHRcdGJveC5sZWZ0ID0gYm94LnRvcDtcblx0XHRcdFx0Ym94LnRvcCA9IHRlbXBWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChib3gud2lkdGggIT09IGJveC5oZWlnaHQpIHtcblx0XHRcdFx0dGVtcFZhbHVlID0gYm94LndpZHRoO1xuXHRcdFx0XHRib3gud2lkdGggPSBib3guaGVpZ2h0O1xuXHRcdFx0XHRib3guaGVpZ2h0ID0gdGVtcFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodHJhbnNmb3JtYXRpb25zLmxlbmd0aCkgYm9keSA9IHdyYXBTVkdDb250ZW50KGJvZHksIFwiPGcgdHJhbnNmb3JtPVxcXCJcIiArIHRyYW5zZm9ybWF0aW9ucy5qb2luKFwiIFwiKSArIFwiXFxcIj5cIiwgXCI8L2c+XCIpO1xuXHR9KTtcblx0Y29uc3QgY3VzdG9taXNhdGlvbnNXaWR0aCA9IGZ1bGxDdXN0b21pc2F0aW9ucy53aWR0aDtcblx0Y29uc3QgY3VzdG9taXNhdGlvbnNIZWlnaHQgPSBmdWxsQ3VzdG9taXNhdGlvbnMuaGVpZ2h0O1xuXHRjb25zdCBib3hXaWR0aCA9IGJveC53aWR0aDtcblx0Y29uc3QgYm94SGVpZ2h0ID0gYm94LmhlaWdodDtcblx0bGV0IHdpZHRoO1xuXHRsZXQgaGVpZ2h0O1xuXHRpZiAoY3VzdG9taXNhdGlvbnNXaWR0aCA9PT0gbnVsbCkge1xuXHRcdGhlaWdodCA9IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID09PSBudWxsID8gXCIxZW1cIiA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID09PSBcImF1dG9cIiA/IGJveEhlaWdodCA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0O1xuXHRcdHdpZHRoID0gY2FsY3VsYXRlU2l6ZShoZWlnaHQsIGJveFdpZHRoIC8gYm94SGVpZ2h0KTtcblx0fSBlbHNlIHtcblx0XHR3aWR0aCA9IGN1c3RvbWlzYXRpb25zV2lkdGggPT09IFwiYXV0b1wiID8gYm94V2lkdGggOiBjdXN0b21pc2F0aW9uc1dpZHRoO1xuXHRcdGhlaWdodCA9IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID09PSBudWxsID8gY2FsY3VsYXRlU2l6ZSh3aWR0aCwgYm94SGVpZ2h0IC8gYm94V2lkdGgpIDogY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IFwiYXV0b1wiID8gYm94SGVpZ2h0IDogY3VzdG9taXNhdGlvbnNIZWlnaHQ7XG5cdH1cblx0Y29uc3QgYXR0cmlidXRlcyA9IHt9O1xuXHRjb25zdCBzZXRBdHRyID0gKHByb3AsIHZhbHVlKSA9PiB7XG5cdFx0aWYgKCFpc1Vuc2V0S2V5d29yZCh2YWx1ZSkpIGF0dHJpYnV0ZXNbcHJvcF0gPSB2YWx1ZS50b1N0cmluZygpO1xuXHR9O1xuXHRzZXRBdHRyKFwid2lkdGhcIiwgd2lkdGgpO1xuXHRzZXRBdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cdGNvbnN0IHZpZXdCb3ggPSBbXG5cdFx0Ym94LmxlZnQsXG5cdFx0Ym94LnRvcCxcblx0XHRib3hXaWR0aCxcblx0XHRib3hIZWlnaHRcblx0XTtcblx0YXR0cmlidXRlcy52aWV3Qm94ID0gdmlld0JveC5qb2luKFwiIFwiKTtcblx0cmV0dXJuIHtcblx0XHRhdHRyaWJ1dGVzLFxuXHRcdHZpZXdCb3gsXG5cdFx0Ym9keVxuXHR9O1xufVxuXG4vKipcbiogSURzIHVzYWdlOlxuKlxuKiBpZD1cIntpZH1cIlxuKiB4bGluazpocmVmPVwiI3tpZH1cIlxuKiB1cmwoI3tpZH0pXG4qXG4qIEZyb20gU1ZHIGFuaW1hdGlvbnM6XG4qXG4qIGJlZ2luPVwiMDt7aWR9LmVuZFwiXG4qIGJlZ2luPVwie2lkfS5lbmRcIlxuKiBiZWdpbj1cIntpZH0uY2xpY2tcIlxuKi9cbi8qKlxuKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIGZpbmRpbmcgaWRzXG4qL1xuY29uc3QgcmVnZXggPSAvXFxzaWQ9XCIoXFxTKylcIi9nO1xuLyoqXG4qIE5ldyByYW5kb20taXNoIHByZWZpeCBmb3IgaWRzXG4qXG4qIERvIG5vdCB1c2UgZGFzaCwgaXQgY2Fubm90IGJlIHVzZWQgaW4gU1ZHIDIgYW5pbWF0aW9uc1xuKi9cbmNvbnN0IHJhbmRvbVByZWZpeCA9IFwiSWNvbmlmeUlkXCIgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDE2KSArIChNYXRoLnJhbmRvbSgpICogMTY3NzcyMTYgfCAwKS50b1N0cmluZygxNik7XG4vKipcbiogQ291bnRlciBmb3IgaWRzLCBpbmNyZWFzaW5nIHdpdGggZXZlcnkgcmVwbGFjZW1lbnRcbiovXG5sZXQgY291bnRlciA9IDA7XG4vKipcbiogUmVwbGFjZSBJRHMgaW4gU1ZHIG91dHB1dCB3aXRoIHVuaXF1ZSBJRHNcbiovXG5mdW5jdGlvbiByZXBsYWNlSURzKGJvZHksIHByZWZpeCA9IHJhbmRvbVByZWZpeCkge1xuXHRjb25zdCBpZHMgPSBbXTtcblx0bGV0IG1hdGNoO1xuXHR3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKGJvZHkpKSBpZHMucHVzaChtYXRjaFsxXSk7XG5cdGlmICghaWRzLmxlbmd0aCkgcmV0dXJuIGJvZHk7XG5cdGNvbnN0IHN1ZmZpeCA9IFwic3VmZml4XCIgKyAoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE2IHwgRGF0ZS5ub3coKSkudG9TdHJpbmcoMTYpO1xuXHRpZHMuZm9yRWFjaCgoaWQpID0+IHtcblx0XHRjb25zdCBuZXdJRCA9IHR5cGVvZiBwcmVmaXggPT09IFwiZnVuY3Rpb25cIiA/IHByZWZpeChpZCkgOiBwcmVmaXggKyAoY291bnRlcisrKS50b1N0cmluZygpO1xuXHRcdGNvbnN0IGVzY2FwZWRJRCA9IGlkLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoWyM7XFxcIl0pKFwiICsgZXNjYXBlZElEICsgXCIpKFtcXFwiKV18XFxcXC5bYS16XSlcIiwgXCJnXCIpLCBcIiQxXCIgKyBuZXdJRCArIHN1ZmZpeCArIFwiJDNcIik7XG5cdH0pO1xuXHRib2R5ID0gYm9keS5yZXBsYWNlKG5ldyBSZWdFeHAoc3VmZml4LCBcImdcIiksIFwiXCIpO1xuXHRyZXR1cm4gYm9keTtcbn1cblxuLyoqXG4qIExvY2FsIHN0b3JhdGUgdHlwZXMgYW5kIGVudHJpZXNcbiovXG5jb25zdCBzdG9yYWdlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuKiBTZXQgQVBJIG1vZHVsZVxuKi9cbmZ1bmN0aW9uIHNldEFQSU1vZHVsZShwcm92aWRlciwgaXRlbSkge1xuXHRzdG9yYWdlW3Byb3ZpZGVyXSA9IGl0ZW07XG59XG4vKipcbiogR2V0IEFQSSBtb2R1bGVcbiovXG5mdW5jdGlvbiBnZXRBUElNb2R1bGUocHJvdmlkZXIpIHtcblx0cmV0dXJuIHN0b3JhZ2VbcHJvdmlkZXJdIHx8IHN0b3JhZ2VbXCJcIl07XG59XG5cbi8qKlxuKiBDcmVhdGUgZnVsbCBBUEkgY29uZmlndXJhdGlvbiBmcm9tIHBhcnRpYWwgZGF0YVxuKi9cbmZ1bmN0aW9uIGNyZWF0ZUFQSUNvbmZpZyhzb3VyY2UpIHtcblx0bGV0IHJlc291cmNlcztcblx0aWYgKHR5cGVvZiBzb3VyY2UucmVzb3VyY2VzID09PSBcInN0cmluZ1wiKSByZXNvdXJjZXMgPSBbc291cmNlLnJlc291cmNlc107XG5cdGVsc2Uge1xuXHRcdHJlc291cmNlcyA9IHNvdXJjZS5yZXNvdXJjZXM7XG5cdFx0aWYgKCEocmVzb3VyY2VzIGluc3RhbmNlb2YgQXJyYXkpIHx8ICFyZXNvdXJjZXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcblx0fVxuXHRjb25zdCByZXN1bHQgPSB7XG5cdFx0cmVzb3VyY2VzLFxuXHRcdHBhdGg6IHNvdXJjZS5wYXRoIHx8IFwiL1wiLFxuXHRcdG1heFVSTDogc291cmNlLm1heFVSTCB8fCA1MDAsXG5cdFx0cm90YXRlOiBzb3VyY2Uucm90YXRlIHx8IDc1MCxcblx0XHR0aW1lb3V0OiBzb3VyY2UudGltZW91dCB8fCA1ZTMsXG5cdFx0cmFuZG9tOiBzb3VyY2UucmFuZG9tID09PSB0cnVlLFxuXHRcdGluZGV4OiBzb3VyY2UuaW5kZXggfHwgMCxcblx0XHRkYXRhQWZ0ZXJUaW1lb3V0OiBzb3VyY2UuZGF0YUFmdGVyVGltZW91dCAhPT0gZmFsc2Vcblx0fTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuKiBMb2NhbCBzdG9yYWdlXG4qL1xuY29uc3QgY29uZmlnU3RvcmFnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbiogUmVkdW5kYW5jeSBmb3IgQVBJIHNlcnZlcnMuXG4qXG4qIEFQSSBzaG91bGQgaGF2ZSB2ZXJ5IGhpZ2ggdXB0aW1lIGJlY2F1c2Ugb2YgaW1wbGVtZW50ZWQgcmVkdW5kYW5jeSBhdCBzZXJ2ZXIgbGV2ZWwsIGJ1dFxuKiBzb21ldGltZXMgYmFkIHRoaW5ncyBoYXBwZW4uIE9uIGludGVybmV0IDEwMCUgdXB0aW1lIGlzIG5vdCBwb3NzaWJsZS5cbipcbiogVGhlcmUgY291bGQgYmUgcm91dGluZyBwcm9ibGVtcy4gU2VydmVyIG1pZ2h0IGdvIGRvd24gZm9yIHdoYXRldmVyIHJlYXNvbiwgYnV0IGl0IHRha2VzXG4qIGZldyBtaW51dGVzIHRvIGRldGVjdCB0aGF0IGRvd250aW1lLCBzbyBkdXJpbmcgdGhvc2UgZmV3IG1pbnV0ZXMgQVBJIG1pZ2h0IG5vdCBiZSBhY2Nlc3NpYmxlLlxuKlxuKiBUaGlzIHNjcmlwdCBoYXMgc29tZSByZWR1bmRhbmN5IHRvIG1pdGlnYXRlIHBvc3NpYmxlIG5ldHdvcmsgaXNzdWVzLlxuKlxuKiBJZiBvbmUgaG9zdCBjYW5ub3QgYmUgcmVhY2hlZCBpbiAncm90YXRlJyAoNzUwIGJ5IGRlZmF1bHQpIG1zLCBzY3JpcHQgd2lsbCB0cnkgdG8gcmV0cmlldmVcbiogZGF0YSBmcm9tIGRpZmZlcmVudCBob3N0LiBIb3N0cyBoYXZlIGRpZmZlcmVudCBjb25maWd1cmF0aW9ucywgcG9pbnRpbmcgdG8gZGlmZmVyZW50XG4qIEFQSSBzZXJ2ZXJzIGhvc3RlZCBhdCBkaWZmZXJlbnQgcHJvdmlkZXJzLlxuKi9cbmNvbnN0IGZhbGxCYWNrQVBJU291cmNlcyA9IFtcImh0dHBzOi8vYXBpLnNpbXBsZXN2Zy5jb21cIiwgXCJodHRwczovL2FwaS51bmlzdmcuY29tXCJdO1xuY29uc3QgZmFsbEJhY2tBUEkgPSBbXTtcbndoaWxlIChmYWxsQmFja0FQSVNvdXJjZXMubGVuZ3RoID4gMCkgaWYgKGZhbGxCYWNrQVBJU291cmNlcy5sZW5ndGggPT09IDEpIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnNoaWZ0KCkpO1xuZWxzZSBpZiAoTWF0aC5yYW5kb20oKSA+IC41KSBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5zaGlmdCgpKTtcbmVsc2UgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMucG9wKCkpO1xuY29uZmlnU3RvcmFnZVtcIlwiXSA9IGNyZWF0ZUFQSUNvbmZpZyh7IHJlc291cmNlczogW1wiaHR0cHM6Ly9hcGkuaWNvbmlmeS5kZXNpZ25cIl0uY29uY2F0KGZhbGxCYWNrQVBJKSB9KTtcbi8qKlxuKiBBZGQgY3VzdG9tIGNvbmZpZyBmb3IgcHJvdmlkZXJcbiovXG5mdW5jdGlvbiBhZGRBUElQcm92aWRlcihwcm92aWRlciwgY3VzdG9tQ29uZmlnKSB7XG5cdGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUFQSUNvbmZpZyhjdXN0b21Db25maWcpO1xuXHRpZiAoY29uZmlnID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbmZpZ1N0b3JhZ2VbcHJvdmlkZXJdID0gY29uZmlnO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuKiBHZXQgQVBJIGNvbmZpZ3VyYXRpb25cbiovXG5mdW5jdGlvbiBnZXRBUElDb25maWcocHJvdmlkZXIpIHtcblx0cmV0dXJuIGNvbmZpZ1N0b3JhZ2VbcHJvdmlkZXJdO1xufVxuLyoqXG4qIExpc3QgQVBJIHByb3ZpZGVyc1xuKi9cbmZ1bmN0aW9uIGxpc3RBUElQcm92aWRlcnMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhjb25maWdTdG9yYWdlKTtcbn1cblxuY29uc3QgZGV0ZWN0RmV0Y2ggPSAoKSA9PiB7XG5cdGxldCBjYWxsYmFjaztcblx0dHJ5IHtcblx0XHRjYWxsYmFjayA9IGZldGNoO1xuXHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNhbGxiYWNrO1xuXHR9IGNhdGNoIChlcnIpIHt9XG59O1xuLyoqXG4qIEZldGNoIGZ1bmN0aW9uXG4qL1xubGV0IGZldGNoTW9kdWxlID0gZGV0ZWN0RmV0Y2goKTtcbi8qKlxuKiBTZXQgY3VzdG9tIGZldGNoKCkgZnVuY3Rpb25cbiovXG5mdW5jdGlvbiBzZXRGZXRjaChmZXRjaCQxKSB7XG5cdGZldGNoTW9kdWxlID0gZmV0Y2gkMTtcbn1cbi8qKlxuKiBHZXQgZmV0Y2goKSBmdW5jdGlvbi4gVXNlZCBieSBJY29uIEZpbmRlciBDb3JlXG4qL1xuZnVuY3Rpb24gZ2V0RmV0Y2goKSB7XG5cdHJldHVybiBmZXRjaE1vZHVsZTtcbn1cbi8qKlxuKiBDYWxjdWxhdGUgbWF4aW11bSBpY29ucyBsaXN0IGxlbmd0aCBmb3IgcHJlZml4XG4qL1xuZnVuY3Rpb24gY2FsY3VsYXRlTWF4TGVuZ3RoKHByb3ZpZGVyLCBwcmVmaXgpIHtcblx0Y29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcblx0aWYgKCFjb25maWcpIHJldHVybiAwO1xuXHRsZXQgcmVzdWx0O1xuXHRpZiAoIWNvbmZpZy5tYXhVUkwpIHJlc3VsdCA9IDA7XG5cdGVsc2Uge1xuXHRcdGxldCBtYXhIb3N0TGVuZ3RoID0gMDtcblx0XHRjb25maWcucmVzb3VyY2VzLmZvckVhY2goKGl0ZW0pID0+IHtcblx0XHRcdGNvbnN0IGhvc3QgPSBpdGVtO1xuXHRcdFx0bWF4SG9zdExlbmd0aCA9IE1hdGgubWF4KG1heEhvc3RMZW5ndGgsIGhvc3QubGVuZ3RoKTtcblx0XHR9KTtcblx0XHRjb25zdCB1cmwgPSBwcmVmaXggKyBcIi5qc29uP2ljb25zPVwiO1xuXHRcdHJlc3VsdCA9IGNvbmZpZy5tYXhVUkwgLSBtYXhIb3N0TGVuZ3RoIC0gY29uZmlnLnBhdGgubGVuZ3RoIC0gdXJsLmxlbmd0aDtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4qIFNob3VsZCBxdWVyeSBiZSBhYm9ydGVkLCBiYXNlZCBvbiBsYXN0IEhUVFAgc3RhdHVzXG4qL1xuZnVuY3Rpb24gc2hvdWxkQWJvcnQoc3RhdHVzKSB7XG5cdHJldHVybiBzdGF0dXMgPT09IDQwNDtcbn1cbi8qKlxuKiBQcmVwYXJlIHBhcmFtc1xuKi9cbmNvbnN0IHByZXBhcmUgPSAocHJvdmlkZXIsIHByZWZpeCwgaWNvbnMpID0+IHtcblx0Y29uc3QgcmVzdWx0cyA9IFtdO1xuXHRjb25zdCBtYXhMZW5ndGggPSBjYWxjdWxhdGVNYXhMZW5ndGgocHJvdmlkZXIsIHByZWZpeCk7XG5cdGNvbnN0IHR5cGUgPSBcImljb25zXCI7XG5cdGxldCBpdGVtID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvdmlkZXIsXG5cdFx0cHJlZml4LFxuXHRcdGljb25zOiBbXVxuXHR9O1xuXHRsZXQgbGVuZ3RoID0gMDtcblx0aWNvbnMuZm9yRWFjaCgobmFtZSwgaW5kZXgpID0+IHtcblx0XHRsZW5ndGggKz0gbmFtZS5sZW5ndGggKyAxO1xuXHRcdGlmIChsZW5ndGggPj0gbWF4TGVuZ3RoICYmIGluZGV4ID4gMCkge1xuXHRcdFx0cmVzdWx0cy5wdXNoKGl0ZW0pO1xuXHRcdFx0aXRlbSA9IHtcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0cHJvdmlkZXIsXG5cdFx0XHRcdHByZWZpeCxcblx0XHRcdFx0aWNvbnM6IFtdXG5cdFx0XHR9O1xuXHRcdFx0bGVuZ3RoID0gbmFtZS5sZW5ndGg7XG5cdFx0fVxuXHRcdGl0ZW0uaWNvbnMucHVzaChuYW1lKTtcblx0fSk7XG5cdHJlc3VsdHMucHVzaChpdGVtKTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuLyoqXG4qIEdldCBwYXRoXG4qL1xuZnVuY3Rpb24gZ2V0UGF0aChwcm92aWRlcikge1xuXHRpZiAodHlwZW9mIHByb3ZpZGVyID09PSBcInN0cmluZ1wiKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcblx0XHRpZiAoY29uZmlnKSByZXR1cm4gY29uZmlnLnBhdGg7XG5cdH1cblx0cmV0dXJuIFwiL1wiO1xufVxuLyoqXG4qIExvYWQgaWNvbnNcbiovXG5jb25zdCBzZW5kID0gKGhvc3QsIHBhcmFtcywgY2FsbGJhY2spID0+IHtcblx0aWYgKCFmZXRjaE1vZHVsZSkge1xuXHRcdGNhbGxiYWNrKFwiYWJvcnRcIiwgNDI0KTtcblx0XHRyZXR1cm47XG5cdH1cblx0bGV0IHBhdGggPSBnZXRQYXRoKHBhcmFtcy5wcm92aWRlcik7XG5cdHN3aXRjaCAocGFyYW1zLnR5cGUpIHtcblx0XHRjYXNlIFwiaWNvbnNcIjoge1xuXHRcdFx0Y29uc3QgcHJlZml4ID0gcGFyYW1zLnByZWZpeDtcblx0XHRcdGNvbnN0IGljb25zID0gcGFyYW1zLmljb25zO1xuXHRcdFx0Y29uc3QgaWNvbnNMaXN0ID0gaWNvbnMuam9pbihcIixcIik7XG5cdFx0XHRjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgaWNvbnM6IGljb25zTGlzdCB9KTtcblx0XHRcdHBhdGggKz0gcHJlZml4ICsgXCIuanNvbj9cIiArIHVybFBhcmFtcy50b1N0cmluZygpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGNhc2UgXCJjdXN0b21cIjoge1xuXHRcdFx0Y29uc3QgdXJpID0gcGFyYW1zLnVyaTtcblx0XHRcdHBhdGggKz0gdXJpLnNsaWNlKDAsIDEpID09PSBcIi9cIiA/IHVyaS5zbGljZSgxKSA6IHVyaTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRkZWZhdWx0OlxuXHRcdFx0Y2FsbGJhY2soXCJhYm9ydFwiLCA0MDApO1xuXHRcdFx0cmV0dXJuO1xuXHR9XG5cdGxldCBkZWZhdWx0RXJyb3IgPSA1MDM7XG5cdGZldGNoTW9kdWxlKGhvc3QgKyBwYXRoKS50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcblx0XHRpZiAoc3RhdHVzICE9PSAyMDApIHtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRjYWxsYmFjayhzaG91bGRBYm9ydChzdGF0dXMpID8gXCJhYm9ydFwiIDogXCJuZXh0XCIsIHN0YXR1cyk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZGVmYXVsdEVycm9yID0gNTAxO1xuXHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cdH0pLnRoZW4oKGRhdGEpID0+IHtcblx0XHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCkge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdGlmIChkYXRhID09PSA0MDQpIGNhbGxiYWNrKFwiYWJvcnRcIiwgZGF0YSk7XG5cdFx0XHRcdGVsc2UgY2FsbGJhY2soXCJuZXh0XCIsIGRlZmF1bHRFcnJvcik7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRjYWxsYmFjayhcInN1Y2Nlc3NcIiwgZGF0YSk7XG5cdFx0fSk7XG5cdH0pLmNhdGNoKCgpID0+IHtcblx0XHRjYWxsYmFjayhcIm5leHRcIiwgZGVmYXVsdEVycm9yKTtcblx0fSk7XG59O1xuLyoqXG4qIEV4cG9ydCBtb2R1bGVcbiovXG5jb25zdCBmZXRjaEFQSU1vZHVsZSA9IHtcblx0cHJlcGFyZSxcblx0c2VuZFxufTtcblxuLyoqXG4qIFJlbW92ZSBjYWxsYmFja1xuKi9cbmZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrKHN0b3JhZ2VzLCBpZCkge1xuXHRzdG9yYWdlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG5cdFx0Y29uc3QgaXRlbXMgPSBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcztcblx0XHRpZiAoaXRlbXMpIHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzID0gaXRlbXMuZmlsdGVyKChyb3cpID0+IHJvdy5pZCAhPT0gaWQpO1xuXHR9KTtcbn1cbi8qKlxuKiBVcGRhdGUgYWxsIGNhbGxiYWNrcyBmb3IgcHJvdmlkZXIgYW5kIHByZWZpeFxuKi9cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrcyhzdG9yYWdlKSB7XG5cdGlmICghc3RvcmFnZS5wZW5kaW5nQ2FsbGJhY2tzRmxhZykge1xuXHRcdHN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0c3RvcmFnZS5wZW5kaW5nQ2FsbGJhY2tzRmxhZyA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgaXRlbXMgPSBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA/IHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzLnNsaWNlKDApIDogW107XG5cdFx0XHRpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXHRcdFx0bGV0IGhhc1BlbmRpbmcgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHByb3ZpZGVyID0gc3RvcmFnZS5wcm92aWRlcjtcblx0XHRcdGNvbnN0IHByZWZpeCA9IHN0b3JhZ2UucHJlZml4O1xuXHRcdFx0aXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdFx0XHRjb25zdCBpY29ucyA9IGl0ZW0uaWNvbnM7XG5cdFx0XHRcdGNvbnN0IG9sZExlbmd0aCA9IGljb25zLnBlbmRpbmcubGVuZ3RoO1xuXHRcdFx0XHRpY29ucy5wZW5kaW5nID0gaWNvbnMucGVuZGluZy5maWx0ZXIoKGljb24pID0+IHtcblx0XHRcdFx0XHRpZiAoaWNvbi5wcmVmaXggIT09IHByZWZpeCkgcmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IGljb24ubmFtZTtcblx0XHRcdFx0XHRpZiAoc3RvcmFnZS5pY29uc1tuYW1lXSkgaWNvbnMubG9hZGVkLnB1c2goe1xuXHRcdFx0XHRcdFx0cHJvdmlkZXIsXG5cdFx0XHRcdFx0XHRwcmVmaXgsXG5cdFx0XHRcdFx0XHRuYW1lXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoc3RvcmFnZS5taXNzaW5nLmhhcyhuYW1lKSkgaWNvbnMubWlzc2luZy5wdXNoKHtcblx0XHRcdFx0XHRcdHByb3ZpZGVyLFxuXHRcdFx0XHRcdFx0cHJlZml4LFxuXHRcdFx0XHRcdFx0bmFtZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aGFzUGVuZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKGljb25zLnBlbmRpbmcubGVuZ3RoICE9PSBvbGRMZW5ndGgpIHtcblx0XHRcdFx0XHRpZiAoIWhhc1BlbmRpbmcpIHJlbW92ZUNhbGxiYWNrKFtzdG9yYWdlXSwgaXRlbS5pZCk7XG5cdFx0XHRcdFx0aXRlbS5jYWxsYmFjayhpY29ucy5sb2FkZWQuc2xpY2UoMCksIGljb25zLm1pc3Npbmcuc2xpY2UoMCksIGljb25zLnBlbmRpbmcuc2xpY2UoMCksIGl0ZW0uYWJvcnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxufVxuLyoqXG4qIFVuaXF1ZSBpZCBjb3VudGVyIGZvciBjYWxsYmFja3NcbiovXG5sZXQgaWRDb3VudGVyID0gMDtcbi8qKlxuKiBBZGQgY2FsbGJhY2tcbiovXG5mdW5jdGlvbiBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBpY29ucywgcGVuZGluZ1NvdXJjZXMpIHtcblx0Y29uc3QgaWQgPSBpZENvdW50ZXIrKztcblx0Y29uc3QgYWJvcnQgPSByZW1vdmVDYWxsYmFjay5iaW5kKG51bGwsIHBlbmRpbmdTb3VyY2VzLCBpZCk7XG5cdGlmICghaWNvbnMucGVuZGluZy5sZW5ndGgpIHJldHVybiBhYm9ydDtcblx0Y29uc3QgaXRlbSA9IHtcblx0XHRpZCxcblx0XHRpY29ucyxcblx0XHRjYWxsYmFjayxcblx0XHRhYm9ydFxuXHR9O1xuXHRwZW5kaW5nU291cmNlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG5cdFx0KHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzIHx8IChzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA9IFtdKSkucHVzaChpdGVtKTtcblx0fSk7XG5cdHJldHVybiBhYm9ydDtcbn1cblxuLyoqXG4qIENoZWNrIGlmIGljb25zIGhhdmUgYmVlbiBsb2FkZWRcbiovXG5mdW5jdGlvbiBzb3J0SWNvbnMoaWNvbnMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdGxvYWRlZDogW10sXG5cdFx0bWlzc2luZzogW10sXG5cdFx0cGVuZGluZzogW11cblx0fTtcblx0Y29uc3Qgc3RvcmFnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGljb25zLnNvcnQoKGEsIGIpID0+IHtcblx0XHRpZiAoYS5wcm92aWRlciAhPT0gYi5wcm92aWRlcikgcmV0dXJuIGEucHJvdmlkZXIubG9jYWxlQ29tcGFyZShiLnByb3ZpZGVyKTtcblx0XHRpZiAoYS5wcmVmaXggIT09IGIucHJlZml4KSByZXR1cm4gYS5wcmVmaXgubG9jYWxlQ29tcGFyZShiLnByZWZpeCk7XG5cdFx0cmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG5cdH0pO1xuXHRsZXQgbGFzdEljb24gPSB7XG5cdFx0cHJvdmlkZXI6IFwiXCIsXG5cdFx0cHJlZml4OiBcIlwiLFxuXHRcdG5hbWU6IFwiXCJcblx0fTtcblx0aWNvbnMuZm9yRWFjaCgoaWNvbikgPT4ge1xuXHRcdGlmIChsYXN0SWNvbi5uYW1lID09PSBpY29uLm5hbWUgJiYgbGFzdEljb24ucHJlZml4ID09PSBpY29uLnByZWZpeCAmJiBsYXN0SWNvbi5wcm92aWRlciA9PT0gaWNvbi5wcm92aWRlcikgcmV0dXJuO1xuXHRcdGxhc3RJY29uID0gaWNvbjtcblx0XHRjb25zdCBwcm92aWRlciA9IGljb24ucHJvdmlkZXI7XG5cdFx0Y29uc3QgcHJlZml4ID0gaWNvbi5wcmVmaXg7XG5cdFx0Y29uc3QgbmFtZSA9IGljb24ubmFtZTtcblx0XHRjb25zdCBwcm92aWRlclN0b3JhZ2UgPSBzdG9yYWdlW3Byb3ZpZGVyXSB8fCAoc3RvcmFnZVtwcm92aWRlcl0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblx0XHRjb25zdCBsb2NhbFN0b3JhZ2UgPSBwcm92aWRlclN0b3JhZ2VbcHJlZml4XSB8fCAocHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpKTtcblx0XHRsZXQgbGlzdDtcblx0XHRpZiAobmFtZSBpbiBsb2NhbFN0b3JhZ2UuaWNvbnMpIGxpc3QgPSByZXN1bHQubG9hZGVkO1xuXHRcdGVsc2UgaWYgKHByZWZpeCA9PT0gXCJcIiB8fCBsb2NhbFN0b3JhZ2UubWlzc2luZy5oYXMobmFtZSkpIGxpc3QgPSByZXN1bHQubWlzc2luZztcblx0XHRlbHNlIGxpc3QgPSByZXN1bHQucGVuZGluZztcblx0XHRjb25zdCBpdGVtID0ge1xuXHRcdFx0cHJvdmlkZXIsXG5cdFx0XHRwcmVmaXgsXG5cdFx0XHRuYW1lXG5cdFx0fTtcblx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiogQ29udmVydCBpY29ucyBsaXN0IGZyb20gc3RyaW5nL2ljb24gbWl4IHRvIGljb25zIGFuZCB2YWxpZGF0ZSB0aGVtXG4qL1xuZnVuY3Rpb24gbGlzdFRvSWNvbnMobGlzdCwgdmFsaWRhdGUgPSB0cnVlLCBzaW1wbGVOYW1lcyA9IGZhbHNlKSB7XG5cdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRsaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcblx0XHRjb25zdCBpY29uID0gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaXRlbSwgdmFsaWRhdGUsIHNpbXBsZU5hbWVzKSA6IGl0ZW07XG5cdFx0aWYgKGljb24pIHJlc3VsdC5wdXNoKGljb24pO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4qIERlZmF1bHQgUmVkdW5kYW5jeUNvbmZpZyBmb3IgQVBJIGNhbGxzXG4qL1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcblx0cmVzb3VyY2VzOiBbXSxcblx0aW5kZXg6IDAsXG5cdHRpbWVvdXQ6IDJlMyxcblx0cm90YXRlOiA3NTAsXG5cdHJhbmRvbTogZmFsc2UsXG5cdGRhdGFBZnRlclRpbWVvdXQ6IGZhbHNlXG59O1xuXG4vKipcbiogU2VuZCBxdWVyeVxuKi9cbmZ1bmN0aW9uIHNlbmRRdWVyeShjb25maWcsIHBheWxvYWQsIHF1ZXJ5LCBkb25lKSB7XG5cdGNvbnN0IHJlc291cmNlc0NvdW50ID0gY29uZmlnLnJlc291cmNlcy5sZW5ndGg7XG5cdGNvbnN0IHN0YXJ0SW5kZXggPSBjb25maWcucmFuZG9tID8gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVzb3VyY2VzQ291bnQpIDogY29uZmlnLmluZGV4O1xuXHRsZXQgcmVzb3VyY2VzO1xuXHRpZiAoY29uZmlnLnJhbmRvbSkge1xuXHRcdGxldCBsaXN0ID0gY29uZmlnLnJlc291cmNlcy5zbGljZSgwKTtcblx0XHRyZXNvdXJjZXMgPSBbXTtcblx0XHR3aGlsZSAobGlzdC5sZW5ndGggPiAxKSB7XG5cdFx0XHRjb25zdCBuZXh0SW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsaXN0Lmxlbmd0aCk7XG5cdFx0XHRyZXNvdXJjZXMucHVzaChsaXN0W25leHRJbmRleF0pO1xuXHRcdFx0bGlzdCA9IGxpc3Quc2xpY2UoMCwgbmV4dEluZGV4KS5jb25jYXQobGlzdC5zbGljZShuZXh0SW5kZXggKyAxKSk7XG5cdFx0fVxuXHRcdHJlc291cmNlcyA9IHJlc291cmNlcy5jb25jYXQobGlzdCk7XG5cdH0gZWxzZSByZXNvdXJjZXMgPSBjb25maWcucmVzb3VyY2VzLnNsaWNlKHN0YXJ0SW5kZXgpLmNvbmNhdChjb25maWcucmVzb3VyY2VzLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcblx0Y29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0bGV0IHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuXHRsZXQgcXVlcmllc1NlbnQgPSAwO1xuXHRsZXQgbGFzdEVycm9yO1xuXHRsZXQgdGltZXIgPSBudWxsO1xuXHRsZXQgcXVldWUgPSBbXTtcblx0bGV0IGRvbmVDYWxsYmFja3MgPSBbXTtcblx0aWYgKHR5cGVvZiBkb25lID09PSBcImZ1bmN0aW9uXCIpIGRvbmVDYWxsYmFja3MucHVzaChkb25lKTtcblx0LyoqXG5cdCogUmVzZXQgdGltZXJcblx0Ki9cblx0ZnVuY3Rpb24gcmVzZXRUaW1lcigpIHtcblx0XHRpZiAodGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHR0aW1lciA9IG51bGw7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEFib3J0IGV2ZXJ5dGhpbmdcblx0Ki9cblx0ZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0aWYgKHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuXHRcdHJlc2V0VGltZXIoKTtcblx0XHRxdWV1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRpZiAoaXRlbS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSBpdGVtLnN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuXHRcdH0pO1xuXHRcdHF1ZXVlID0gW107XG5cdH1cblx0LyoqXG5cdCogQWRkIC8gcmVwbGFjZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gZXhlY3V0aW9uIGlzIGNvbXBsZXRlLlxuXHQqIFRoaXMgY2FuIGJlIHVzZWQgdG8gYWJvcnQgcGVuZGluZyBxdWVyeSBpbXBsZW1lbnRhdGlvbnMgd2hlbiBxdWVyeSBpcyBjb21wbGV0ZSBvciBhYm9ydGVkLlxuXHQqL1xuXHRmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2ssIG92ZXJ3cml0ZSkge1xuXHRcdGlmIChvdmVyd3JpdGUpIGRvbmVDYWxsYmFja3MgPSBbXTtcblx0XHRpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIGRvbmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdH1cblx0LyoqXG5cdCogR2V0IHF1ZXJ5IHN0YXR1c1xuXHQqL1xuXHRmdW5jdGlvbiBnZXRRdWVyeVN0YXR1cygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnRUaW1lLFxuXHRcdFx0cGF5bG9hZCxcblx0XHRcdHN0YXR1cyxcblx0XHRcdHF1ZXJpZXNTZW50LFxuXHRcdFx0cXVlcmllc1BlbmRpbmc6IHF1ZXVlLmxlbmd0aCxcblx0XHRcdHN1YnNjcmliZSxcblx0XHRcdGFib3J0XG5cdFx0fTtcblx0fVxuXHQvKipcblx0KiBGYWlsIHF1ZXJ5XG5cdCovXG5cdGZ1bmN0aW9uIGZhaWxRdWVyeSgpIHtcblx0XHRzdGF0dXMgPSBcImZhaWxlZFwiO1xuXHRcdGRvbmVDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcblx0XHRcdGNhbGxiYWNrKHZvaWQgMCwgbGFzdEVycm9yKTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBDbGVhciBxdWV1ZVxuXHQqL1xuXHRmdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuXHRcdHF1ZXVlLmZvckVhY2goKGl0ZW0pID0+IHtcblx0XHRcdGlmIChpdGVtLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIGl0ZW0uc3RhdHVzID0gXCJhYm9ydGVkXCI7XG5cdFx0fSk7XG5cdFx0cXVldWUgPSBbXTtcblx0fVxuXHQvKipcblx0KiBHb3QgcmVzcG9uc2UgZnJvbSBtb2R1bGVcblx0Ki9cblx0ZnVuY3Rpb24gbW9kdWxlUmVzcG9uc2UoaXRlbSwgcmVzcG9uc2UsIGRhdGEpIHtcblx0XHRjb25zdCBpc0Vycm9yID0gcmVzcG9uc2UgIT09IFwic3VjY2Vzc1wiO1xuXHRcdHF1ZXVlID0gcXVldWUuZmlsdGVyKChxdWV1ZWQpID0+IHF1ZXVlZCAhPT0gaXRlbSk7XG5cdFx0c3dpdGNoIChzdGF0dXMpIHtcblx0XHRcdGNhc2UgXCJwZW5kaW5nXCI6IGJyZWFrO1xuXHRcdFx0Y2FzZSBcImZhaWxlZFwiOlxuXHRcdFx0XHRpZiAoaXNFcnJvciB8fCAhY29uZmlnLmRhdGFBZnRlclRpbWVvdXQpIHJldHVybjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OiByZXR1cm47XG5cdFx0fVxuXHRcdGlmIChyZXNwb25zZSA9PT0gXCJhYm9ydFwiKSB7XG5cdFx0XHRsYXN0RXJyb3IgPSBkYXRhO1xuXHRcdFx0ZmFpbFF1ZXJ5KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChpc0Vycm9yKSB7XG5cdFx0XHRsYXN0RXJyb3IgPSBkYXRhO1xuXHRcdFx0aWYgKCFxdWV1ZS5sZW5ndGgpIGlmICghcmVzb3VyY2VzLmxlbmd0aCkgZmFpbFF1ZXJ5KCk7XG5cdFx0XHRlbHNlIGV4ZWNOZXh0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHJlc2V0VGltZXIoKTtcblx0XHRjbGVhclF1ZXVlKCk7XG5cdFx0aWYgKCFjb25maWcucmFuZG9tKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IGNvbmZpZy5yZXNvdXJjZXMuaW5kZXhPZihpdGVtLnJlc291cmNlKTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEgJiYgaW5kZXggIT09IGNvbmZpZy5pbmRleCkgY29uZmlnLmluZGV4ID0gaW5kZXg7XG5cdFx0fVxuXHRcdHN0YXR1cyA9IFwiY29tcGxldGVkXCI7XG5cdFx0ZG9uZUNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuXHRcdFx0Y2FsbGJhY2soZGF0YSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogRXhlY3V0ZSBuZXh0IHF1ZXJ5XG5cdCovXG5cdGZ1bmN0aW9uIGV4ZWNOZXh0KCkge1xuXHRcdGlmIChzdGF0dXMgIT09IFwicGVuZGluZ1wiKSByZXR1cm47XG5cdFx0cmVzZXRUaW1lcigpO1xuXHRcdGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzLnNoaWZ0KCk7XG5cdFx0aWYgKHJlc291cmNlID09PSB2b2lkIDApIHtcblx0XHRcdGlmIChxdWV1ZS5sZW5ndGgpIHtcblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRyZXNldFRpbWVyKCk7XG5cdFx0XHRcdFx0aWYgKHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcblx0XHRcdFx0XHRcdGNsZWFyUXVldWUoKTtcblx0XHRcdFx0XHRcdGZhaWxRdWVyeSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgY29uZmlnLnRpbWVvdXQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRmYWlsUXVlcnkoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgaXRlbSA9IHtcblx0XHRcdHN0YXR1czogXCJwZW5kaW5nXCIsXG5cdFx0XHRyZXNvdXJjZSxcblx0XHRcdGNhbGxiYWNrOiAoc3RhdHVzJDEsIGRhdGEpID0+IHtcblx0XHRcdFx0bW9kdWxlUmVzcG9uc2UoaXRlbSwgc3RhdHVzJDEsIGRhdGEpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cXVldWUucHVzaChpdGVtKTtcblx0XHRxdWVyaWVzU2VudCsrO1xuXHRcdHRpbWVyID0gc2V0VGltZW91dChleGVjTmV4dCwgY29uZmlnLnJvdGF0ZSk7XG5cdFx0cXVlcnkocmVzb3VyY2UsIHBheWxvYWQsIGl0ZW0uY2FsbGJhY2spO1xuXHR9XG5cdHNldFRpbWVvdXQoZXhlY05leHQpO1xuXHRyZXR1cm4gZ2V0UXVlcnlTdGF0dXM7XG59XG5cbi8qKlxuKiBSZWR1bmRhbmN5IGluc3RhbmNlXG4qL1xuZnVuY3Rpb24gaW5pdFJlZHVuZGFuY3koY2ZnKSB7XG5cdGNvbnN0IGNvbmZpZyA9IHtcblx0XHQuLi5kZWZhdWx0Q29uZmlnLFxuXHRcdC4uLmNmZ1xuXHR9O1xuXHRsZXQgcXVlcmllcyA9IFtdO1xuXHQvKipcblx0KiBSZW1vdmUgYWJvcnRlZCBhbmQgY29tcGxldGVkIHF1ZXJpZXNcblx0Ki9cblx0ZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0XHRxdWVyaWVzID0gcXVlcmllcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0oKS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKTtcblx0fVxuXHQvKipcblx0KiBTZW5kIHF1ZXJ5XG5cdCovXG5cdGZ1bmN0aW9uIHF1ZXJ5KHBheWxvYWQsIHF1ZXJ5Q2FsbGJhY2ssIGRvbmVDYWxsYmFjaykge1xuXHRcdGNvbnN0IHF1ZXJ5JDEgPSBzZW5kUXVlcnkoY29uZmlnLCBwYXlsb2FkLCBxdWVyeUNhbGxiYWNrLCAoZGF0YSwgZXJyb3IpID0+IHtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdGlmIChkb25lQ2FsbGJhY2spIGRvbmVDYWxsYmFjayhkYXRhLCBlcnJvcik7XG5cdFx0fSk7XG5cdFx0cXVlcmllcy5wdXNoKHF1ZXJ5JDEpO1xuXHRcdHJldHVybiBxdWVyeSQxO1xuXHR9XG5cdC8qKlxuXHQqIEZpbmQgaW5zdGFuY2Vcblx0Ki9cblx0ZnVuY3Rpb24gZmluZChjYWxsYmFjaykge1xuXHRcdHJldHVybiBxdWVyaWVzLmZpbmQoKHZhbHVlKSA9PiB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sodmFsdWUpO1xuXHRcdH0pIHx8IG51bGw7XG5cdH1cblx0Y29uc3QgaW5zdGFuY2UgPSB7XG5cdFx0cXVlcnksXG5cdFx0ZmluZCxcblx0XHRzZXRJbmRleDogKGluZGV4KSA9PiB7XG5cdFx0XHRjb25maWcuaW5kZXggPSBpbmRleDtcblx0XHR9LFxuXHRcdGdldEluZGV4OiAoKSA9PiBjb25maWcuaW5kZXgsXG5cdFx0Y2xlYW51cFxuXHR9O1xuXHRyZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGVtcHR5Q2FsbGJhY2skMSgpIHt9XG5jb25zdCByZWR1bmRhbmN5Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG4qIEdldCBSZWR1bmRhbmN5IGluc3RhbmNlIGZvciBwcm92aWRlclxuKi9cbmZ1bmN0aW9uIGdldFJlZHVuZGFuY3lDYWNoZShwcm92aWRlcikge1xuXHRpZiAoIXJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0pIHtcblx0XHRjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuXHRcdGlmICghY29uZmlnKSByZXR1cm47XG5cdFx0Y29uc3QgcmVkdW5kYW5jeSA9IGluaXRSZWR1bmRhbmN5KGNvbmZpZyk7XG5cdFx0Y29uc3QgY2FjaGVkUmV1bmRhbmN5ID0ge1xuXHRcdFx0Y29uZmlnLFxuXHRcdFx0cmVkdW5kYW5jeVxuXHRcdH07XG5cdFx0cmVkdW5kYW5jeUNhY2hlW3Byb3ZpZGVyXSA9IGNhY2hlZFJldW5kYW5jeTtcblx0fVxuXHRyZXR1cm4gcmVkdW5kYW5jeUNhY2hlW3Byb3ZpZGVyXTtcbn1cbi8qKlxuKiBTZW5kIEFQSSBxdWVyeVxuKi9cbmZ1bmN0aW9uIHNlbmRBUElRdWVyeSh0YXJnZXQsIHF1ZXJ5LCBjYWxsYmFjaykge1xuXHRsZXQgcmVkdW5kYW5jeTtcblx0bGV0IHNlbmQ7XG5cdGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG5cdFx0Y29uc3QgYXBpID0gZ2V0QVBJTW9kdWxlKHRhcmdldCk7XG5cdFx0aWYgKCFhcGkpIHtcblx0XHRcdGNhbGxiYWNrKHZvaWQgMCwgNDI0KTtcblx0XHRcdHJldHVybiBlbXB0eUNhbGxiYWNrJDE7XG5cdFx0fVxuXHRcdHNlbmQgPSBhcGkuc2VuZDtcblx0XHRjb25zdCBjYWNoZWQgPSBnZXRSZWR1bmRhbmN5Q2FjaGUodGFyZ2V0KTtcblx0XHRpZiAoY2FjaGVkKSByZWR1bmRhbmN5ID0gY2FjaGVkLnJlZHVuZGFuY3k7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgY29uZmlnID0gY3JlYXRlQVBJQ29uZmlnKHRhcmdldCk7XG5cdFx0aWYgKGNvbmZpZykge1xuXHRcdFx0cmVkdW5kYW5jeSA9IGluaXRSZWR1bmRhbmN5KGNvbmZpZyk7XG5cdFx0XHRjb25zdCBtb2R1bGVLZXkgPSB0YXJnZXQucmVzb3VyY2VzID8gdGFyZ2V0LnJlc291cmNlc1swXSA6IFwiXCI7XG5cdFx0XHRjb25zdCBhcGkgPSBnZXRBUElNb2R1bGUobW9kdWxlS2V5KTtcblx0XHRcdGlmIChhcGkpIHNlbmQgPSBhcGkuc2VuZDtcblx0XHR9XG5cdH1cblx0aWYgKCFyZWR1bmRhbmN5IHx8ICFzZW5kKSB7XG5cdFx0Y2FsbGJhY2sodm9pZCAwLCA0MjQpO1xuXHRcdHJldHVybiBlbXB0eUNhbGxiYWNrJDE7XG5cdH1cblx0cmV0dXJuIHJlZHVuZGFuY3kucXVlcnkocXVlcnksIHNlbmQsIGNhbGxiYWNrKSgpLmFib3J0O1xufVxuXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrKCkge31cbi8qKlxuKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiBuZXcgaWNvbnMgaGF2ZSBiZWVuIGxvYWRlZFxuKi9cbmZ1bmN0aW9uIGxvYWRlZE5ld0ljb25zKHN0b3JhZ2UpIHtcblx0aWYgKCFzdG9yYWdlLmljb25zTG9hZGVyRmxhZykge1xuXHRcdHN0b3JhZ2UuaWNvbnNMb2FkZXJGbGFnID0gdHJ1ZTtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHN0b3JhZ2UuaWNvbnNMb2FkZXJGbGFnID0gZmFsc2U7XG5cdFx0XHR1cGRhdGVDYWxsYmFja3Moc3RvcmFnZSk7XG5cdFx0fSk7XG5cdH1cbn1cbi8qKlxuKiBDaGVjayBpY29uIG5hbWVzIGZvciBBUElcbiovXG5mdW5jdGlvbiBjaGVja0ljb25OYW1lc0ZvckFQSShpY29ucykge1xuXHRjb25zdCB2YWxpZCA9IFtdO1xuXHRjb25zdCBpbnZhbGlkID0gW107XG5cdGljb25zLmZvckVhY2goKG5hbWUpID0+IHtcblx0XHQobmFtZS5tYXRjaChtYXRjaEljb25OYW1lKSA/IHZhbGlkIDogaW52YWxpZCkucHVzaChuYW1lKTtcblx0fSk7XG5cdHJldHVybiB7XG5cdFx0dmFsaWQsXG5cdFx0aW52YWxpZFxuXHR9O1xufVxuLyoqXG4qIFBhcnNlIGxvYWRlciByZXNwb25zZVxuKi9cbmZ1bmN0aW9uIHBhcnNlTG9hZGVyUmVzcG9uc2Uoc3RvcmFnZSwgaWNvbnMsIGRhdGEpIHtcblx0ZnVuY3Rpb24gY2hlY2tNaXNzaW5nKCkge1xuXHRcdGNvbnN0IHBlbmRpbmcgPSBzdG9yYWdlLnBlbmRpbmdJY29ucztcblx0XHRpY29ucy5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0XHRpZiAocGVuZGluZykgcGVuZGluZy5kZWxldGUobmFtZSk7XG5cdFx0XHRpZiAoIXN0b3JhZ2UuaWNvbnNbbmFtZV0pIHN0b3JhZ2UubWlzc2luZy5hZGQobmFtZSk7XG5cdFx0fSk7XG5cdH1cblx0aWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHRyeSB7XG5cdFx0Y29uc3QgcGFyc2VkID0gYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKTtcblx0XHRpZiAoIXBhcnNlZC5sZW5ndGgpIHtcblx0XHRcdGNoZWNrTWlzc2luZygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Y29uc29sZS5lcnJvcihlcnIpO1xuXHR9XG5cdGNoZWNrTWlzc2luZygpO1xuXHRsb2FkZWROZXdJY29ucyhzdG9yYWdlKTtcbn1cbi8qKlxuKiBIYW5kbGUgcmVzcG9uc2UgdGhhdCBjYW4gYmUgYXN5bmNcbiovXG5mdW5jdGlvbiBwYXJzZVBvc3NpYmx5QXN5bmNSZXNwb25zZShyZXNwb25zZSwgY2FsbGJhY2spIHtcblx0aWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmVzcG9uc2UudGhlbigoZGF0YSkgPT4ge1xuXHRcdGNhbGxiYWNrKGRhdGEpO1xuXHR9KS5jYXRjaCgoKSA9PiB7XG5cdFx0Y2FsbGJhY2sobnVsbCk7XG5cdH0pO1xuXHRlbHNlIGNhbGxiYWNrKHJlc3BvbnNlKTtcbn1cbi8qKlxuKiBMb2FkIGljb25zXG4qL1xuZnVuY3Rpb24gbG9hZE5ld0ljb25zKHN0b3JhZ2UsIGljb25zKSB7XG5cdGlmICghc3RvcmFnZS5pY29uc1RvTG9hZCkgc3RvcmFnZS5pY29uc1RvTG9hZCA9IGljb25zO1xuXHRlbHNlIHN0b3JhZ2UuaWNvbnNUb0xvYWQgPSBzdG9yYWdlLmljb25zVG9Mb2FkLmNvbmNhdChpY29ucykuc29ydCgpO1xuXHRpZiAoIXN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcpIHtcblx0XHRzdG9yYWdlLmljb25zUXVldWVGbGFnID0gdHJ1ZTtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHsgcHJvdmlkZXIsIHByZWZpeCB9ID0gc3RvcmFnZTtcblx0XHRcdGNvbnN0IGljb25zJDEgPSBzdG9yYWdlLmljb25zVG9Mb2FkO1xuXHRcdFx0ZGVsZXRlIHN0b3JhZ2UuaWNvbnNUb0xvYWQ7XG5cdFx0XHRpZiAoIWljb25zJDEgfHwgIWljb25zJDEubGVuZ3RoKSByZXR1cm47XG5cdFx0XHRjb25zdCBjdXN0b21JY29uTG9hZGVyID0gc3RvcmFnZS5sb2FkSWNvbjtcblx0XHRcdGlmIChzdG9yYWdlLmxvYWRJY29ucyAmJiAoaWNvbnMkMS5sZW5ndGggPiAxIHx8ICFjdXN0b21JY29uTG9hZGVyKSkge1xuXHRcdFx0XHRwYXJzZVBvc3NpYmx5QXN5bmNSZXNwb25zZShzdG9yYWdlLmxvYWRJY29ucyhpY29ucyQxLCBwcmVmaXgsIHByb3ZpZGVyKSwgKGRhdGEpID0+IHtcblx0XHRcdFx0XHRwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGljb25zJDEsIGRhdGEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1c3RvbUljb25Mb2FkZXIpIHtcblx0XHRcdFx0aWNvbnMkMS5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBjdXN0b21JY29uTG9hZGVyKG5hbWUsIHByZWZpeCwgcHJvdmlkZXIpO1xuXHRcdFx0XHRcdHBhcnNlUG9zc2libHlBc3luY1Jlc3BvbnNlKHJlc3BvbnNlLCAoZGF0YSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgaWNvblNldCA9IGRhdGEgPyB7XG5cdFx0XHRcdFx0XHRcdHByZWZpeCxcblx0XHRcdFx0XHRcdFx0aWNvbnM6IHsgW25hbWVdOiBkYXRhIH1cblx0XHRcdFx0XHRcdH0gOiBudWxsO1xuXHRcdFx0XHRcdFx0cGFyc2VMb2FkZXJSZXNwb25zZShzdG9yYWdlLCBbbmFtZV0sIGljb25TZXQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgeyB2YWxpZCwgaW52YWxpZCB9ID0gY2hlY2tJY29uTmFtZXNGb3JBUEkoaWNvbnMkMSk7XG5cdFx0XHRpZiAoaW52YWxpZC5sZW5ndGgpIHBhcnNlTG9hZGVyUmVzcG9uc2Uoc3RvcmFnZSwgaW52YWxpZCwgbnVsbCk7XG5cdFx0XHRpZiAoIXZhbGlkLmxlbmd0aCkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgYXBpID0gcHJlZml4Lm1hdGNoKG1hdGNoSWNvbk5hbWUpID8gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSA6IG51bGw7XG5cdFx0XHRpZiAoIWFwaSkge1xuXHRcdFx0XHRwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIHZhbGlkLCBudWxsKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgcGFyYW1zID0gYXBpLnByZXBhcmUocHJvdmlkZXIsIHByZWZpeCwgdmFsaWQpO1xuXHRcdFx0cGFyYW1zLmZvckVhY2goKGl0ZW0pID0+IHtcblx0XHRcdFx0c2VuZEFQSVF1ZXJ5KHByb3ZpZGVyLCBpdGVtLCAoZGF0YSkgPT4ge1xuXHRcdFx0XHRcdHBhcnNlTG9hZGVyUmVzcG9uc2Uoc3RvcmFnZSwgaXRlbS5pY29ucywgZGF0YSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cbn1cbi8qKlxuKiBMb2FkIGljb25zXG4qL1xuY29uc3QgbG9hZEljb25zID0gKGljb25zLCBjYWxsYmFjaykgPT4ge1xuXHRjb25zdCBjbGVhbmVkSWNvbnMgPSBsaXN0VG9JY29ucyhpY29ucywgdHJ1ZSwgYWxsb3dTaW1wbGVOYW1lcygpKTtcblx0Y29uc3Qgc29ydGVkSWNvbnMgPSBzb3J0SWNvbnMoY2xlYW5lZEljb25zKTtcblx0aWYgKCFzb3J0ZWRJY29ucy5wZW5kaW5nLmxlbmd0aCkge1xuXHRcdGxldCBjYWxsQ2FsbGJhY2sgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpZiAoY2FsbENhbGxiYWNrKSBjYWxsYmFjayhzb3J0ZWRJY29ucy5sb2FkZWQsIHNvcnRlZEljb25zLm1pc3NpbmcsIHNvcnRlZEljb25zLnBlbmRpbmcsIGVtcHR5Q2FsbGJhY2spO1xuXHRcdH0pO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRjYWxsQ2FsbGJhY2sgPSBmYWxzZTtcblx0XHR9O1xuXHR9XG5cdGNvbnN0IG5ld0ljb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0Y29uc3Qgc291cmNlcyA9IFtdO1xuXHRsZXQgbGFzdFByb3ZpZGVyLCBsYXN0UHJlZml4O1xuXHRzb3J0ZWRJY29ucy5wZW5kaW5nLmZvckVhY2goKGljb24pID0+IHtcblx0XHRjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXggfSA9IGljb247XG5cdFx0aWYgKHByZWZpeCA9PT0gbGFzdFByZWZpeCAmJiBwcm92aWRlciA9PT0gbGFzdFByb3ZpZGVyKSByZXR1cm47XG5cdFx0bGFzdFByb3ZpZGVyID0gcHJvdmlkZXI7XG5cdFx0bGFzdFByZWZpeCA9IHByZWZpeDtcblx0XHRzb3VyY2VzLnB1c2goZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG5cdFx0Y29uc3QgcHJvdmlkZXJOZXdJY29ucyA9IG5ld0ljb25zW3Byb3ZpZGVyXSB8fCAobmV3SWNvbnNbcHJvdmlkZXJdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdFx0aWYgKCFwcm92aWRlck5ld0ljb25zW3ByZWZpeF0pIHByb3ZpZGVyTmV3SWNvbnNbcHJlZml4XSA9IFtdO1xuXHR9KTtcblx0c29ydGVkSWNvbnMucGVuZGluZy5mb3JFYWNoKChpY29uKSA9PiB7XG5cdFx0Y29uc3QgeyBwcm92aWRlciwgcHJlZml4LCBuYW1lIH0gPSBpY29uO1xuXHRcdGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpO1xuXHRcdGNvbnN0IHBlbmRpbmdRdWV1ZSA9IHN0b3JhZ2UucGVuZGluZ0ljb25zIHx8IChzdG9yYWdlLnBlbmRpbmdJY29ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuXHRcdGlmICghcGVuZGluZ1F1ZXVlLmhhcyhuYW1lKSkge1xuXHRcdFx0cGVuZGluZ1F1ZXVlLmFkZChuYW1lKTtcblx0XHRcdG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdLnB1c2gobmFtZSk7XG5cdFx0fVxuXHR9KTtcblx0c291cmNlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG5cdFx0Y29uc3QgbGlzdCA9IG5ld0ljb25zW3N0b3JhZ2UucHJvdmlkZXJdW3N0b3JhZ2UucHJlZml4XTtcblx0XHRpZiAobGlzdC5sZW5ndGgpIGxvYWROZXdJY29ucyhzdG9yYWdlLCBsaXN0KTtcblx0fSk7XG5cdHJldHVybiBjYWxsYmFjayA/IHN0b3JlQ2FsbGJhY2soY2FsbGJhY2ssIHNvcnRlZEljb25zLCBzb3VyY2VzKSA6IGVtcHR5Q2FsbGJhY2s7XG59O1xuLyoqXG4qIExvYWQgb25lIGljb24gdXNpbmcgUHJvbWlzZVxuKi9cbmNvbnN0IGxvYWRJY29uID0gKGljb24pID0+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcblx0XHRjb25zdCBpY29uT2JqID0gdHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaWNvbiwgdHJ1ZSkgOiBpY29uO1xuXHRcdGlmICghaWNvbk9iaikge1xuXHRcdFx0cmVqZWN0KGljb24pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsb2FkSWNvbnMoW2ljb25PYmogfHwgaWNvbl0sIChsb2FkZWQpID0+IHtcblx0XHRcdGlmIChsb2FkZWQubGVuZ3RoICYmIGljb25PYmopIHtcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGdldEljb25EYXRhKGljb25PYmopO1xuXHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdGZ1bGZpbGwoe1xuXHRcdFx0XHRcdFx0Li4uZGVmYXVsdEljb25Qcm9wcyxcblx0XHRcdFx0XHRcdC4uLmRhdGFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChpY29uKTtcblx0XHR9KTtcblx0fSk7XG59O1xuXG4vKipcbiogU2V0IGN1c3RvbSBsb2FkZXIgZm9yIG11bHRpcGxlIGljb25zXG4qL1xuZnVuY3Rpb24gc2V0Q3VzdG9tSWNvbnNMb2FkZXIobG9hZGVyLCBwcmVmaXgsIHByb3ZpZGVyKSB7XG5cdGdldFN0b3JhZ2UocHJvdmlkZXIgfHwgXCJcIiwgcHJlZml4KS5sb2FkSWNvbnMgPSBsb2FkZXI7XG59XG4vKipcbiogU2V0IGN1c3RvbSBsb2FkZXIgZm9yIG9uZSBpY29uXG4qL1xuZnVuY3Rpb24gc2V0Q3VzdG9tSWNvbkxvYWRlcihsb2FkZXIsIHByZWZpeCwgcHJvdmlkZXIpIHtcblx0Z2V0U3RvcmFnZShwcm92aWRlciB8fCBcIlwiLCBwcmVmaXgpLmxvYWRJY29uID0gbG9hZGVyO1xufVxuXG4vKipcbiogQ29udmVydCBJY29uaWZ5SWNvbkN1c3RvbWlzYXRpb25zIHRvIEZ1bGxJY29uQ3VzdG9taXNhdGlvbnMsIGNoZWNraW5nIHZhbHVlIHR5cGVzXG4qL1xuZnVuY3Rpb24gbWVyZ2VDdXN0b21pc2F0aW9ucyhkZWZhdWx0cywgaXRlbSkge1xuXHRjb25zdCByZXN1bHQgPSB7IC4uLmRlZmF1bHRzIH07XG5cdGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcblx0XHRjb25zdCB2YWx1ZSA9IGl0ZW1ba2V5XTtcblx0XHRjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdFx0aWYgKGtleSBpbiBkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucykge1xuXHRcdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlICYmICh2YWx1ZVR5cGUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWVUeXBlID09PSBcIm51bWJlclwiKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gdHlwZW9mIHJlc3VsdFtrZXldKSByZXN1bHRba2V5XSA9IGtleSA9PT0gXCJyb3RhdGVcIiA/IHZhbHVlICUgNCA6IHZhbHVlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHNlcGFyYXRvciA9IC9bXFxzLF0rLztcbi8qKlxuKiBBcHBseSBcImZsaXBcIiBzdHJpbmcgdG8gaWNvbiBjdXN0b21pc2F0aW9uc1xuKi9cbmZ1bmN0aW9uIGZsaXBGcm9tU3RyaW5nKGN1c3RvbSwgZmxpcCkge1xuXHRmbGlwLnNwbGl0KHNlcGFyYXRvcikuZm9yRWFjaCgoc3RyKSA9PiB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHIudHJpbSgpO1xuXHRcdHN3aXRjaCAodmFsdWUpIHtcblx0XHRcdGNhc2UgXCJob3Jpem9udGFsXCI6XG5cdFx0XHRcdGN1c3RvbS5oRmxpcCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInZlcnRpY2FsXCI6XG5cdFx0XHRcdGN1c3RvbS52RmxpcCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuKiBHZXQgcm90YXRpb24gdmFsdWVcbiovXG5mdW5jdGlvbiByb3RhdGVGcm9tU3RyaW5nKHZhbHVlLCBkZWZhdWx0VmFsdWUgPSAwKSB7XG5cdGNvbnN0IHVuaXRzID0gdmFsdWUucmVwbGFjZSgvXi0/WzAtOS5dKi8sIFwiXCIpO1xuXHRmdW5jdGlvbiBjbGVhbnVwKHZhbHVlJDEpIHtcblx0XHR3aGlsZSAodmFsdWUkMSA8IDApIHZhbHVlJDEgKz0gNDtcblx0XHRyZXR1cm4gdmFsdWUkMSAlIDQ7XG5cdH1cblx0aWYgKHVuaXRzID09PSBcIlwiKSB7XG5cdFx0Y29uc3QgbnVtID0gcGFyc2VJbnQodmFsdWUpO1xuXHRcdHJldHVybiBpc05hTihudW0pID8gMCA6IGNsZWFudXAobnVtKTtcblx0fSBlbHNlIGlmICh1bml0cyAhPT0gdmFsdWUpIHtcblx0XHRsZXQgc3BsaXQgPSAwO1xuXHRcdHN3aXRjaCAodW5pdHMpIHtcblx0XHRcdGNhc2UgXCIlXCI6XG5cdFx0XHRcdHNwbGl0ID0gMjU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImRlZ1wiOiBzcGxpdCA9IDkwO1xuXHRcdH1cblx0XHRpZiAoc3BsaXQpIHtcblx0XHRcdGxldCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCAtIHVuaXRzLmxlbmd0aCkpO1xuXHRcdFx0aWYgKGlzTmFOKG51bSkpIHJldHVybiAwO1xuXHRcdFx0bnVtID0gbnVtIC8gc3BsaXQ7XG5cdFx0XHRyZXR1cm4gbnVtICUgMSA9PT0gMCA/IGNsZWFudXAobnVtKSA6IDA7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuKiBHZW5lcmF0ZSA8c3ZnPlxuKi9cbmZ1bmN0aW9uIGljb25Ub0hUTUwoYm9keSwgYXR0cmlidXRlcykge1xuXHRsZXQgcmVuZGVyQXR0cmlic0hUTUwgPSBib2R5LmluZGV4T2YoXCJ4bGluazpcIikgPT09IC0xID8gXCJcIiA6IFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIlwiO1xuXHRmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykgcmVuZGVyQXR0cmlic0hUTUwgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiICsgYXR0cmlidXRlc1thdHRyXSArIFwiXFxcIlwiO1xuXHRyZXR1cm4gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcIiArIHJlbmRlckF0dHJpYnNIVE1MICsgXCI+XCIgKyBib2R5ICsgXCI8L3N2Zz5cIjtcbn1cblxuLyoqXG4qIEVuY29kZSBTVkcgZm9yIHVzZSBpbiB1cmwoKVxuKlxuKiBTaG9ydCBhbHRlcm5hdGl2ZSB0byBlbmNvZGVVUklDb21wb25lbnQoKSB0aGF0IGVuY29kZXMgb25seSBzdHVmZiB1c2VkIGluIFNWRywgZ2VuZXJhdGluZ1xuKiBzbWFsbGVyIGNvZGUuXG4qL1xuZnVuY3Rpb24gZW5jb2RlU1ZHZm9yVVJMKHN2Zykge1xuXHRyZXR1cm4gc3ZnLnJlcGxhY2UoL1wiL2csIFwiJ1wiKS5yZXBsYWNlKC8lL2csIFwiJTI1XCIpLnJlcGxhY2UoLyMvZywgXCIlMjNcIikucmVwbGFjZSgvPC9nLCBcIiUzQ1wiKS5yZXBsYWNlKC8+L2csIFwiJTNFXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xufVxuLyoqXG4qIEdlbmVyYXRlIGRhdGE6IFVSTCBmcm9tIFNWR1xuKi9cbmZ1bmN0aW9uIHN2Z1RvRGF0YShzdmcpIHtcblx0cmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sLFwiICsgZW5jb2RlU1ZHZm9yVVJMKHN2Zyk7XG59XG4vKipcbiogR2VuZXJhdGUgdXJsKCkgZnJvbSBTVkdcbiovXG5mdW5jdGlvbiBzdmdUb1VSTChzdmcpIHtcblx0cmV0dXJuIFwidXJsKFxcXCJcIiArIHN2Z1RvRGF0YShzdmcpICsgXCJcXFwiKVwiO1xufVxuXG5sZXQgcG9saWN5O1xuLyoqXG4qIEF0dGVtcHQgdG8gY3JlYXRlIHBvbGljeVxuKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvbGljeSgpIHtcblx0dHJ5IHtcblx0XHRwb2xpY3kgPSB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcImljb25pZnlcIiwgeyBjcmVhdGVIVE1MOiAocykgPT4gcyB9KTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0cG9saWN5ID0gbnVsbDtcblx0fVxufVxuLyoqXG4qIENsZWFuIHVwIHZhbHVlIGZvciBpbm5lckhUTUwgYXNzaWdubWVudFxuKlxuKiBUaGlzIGNvZGUgZG9lc24ndCBhY3R1YWxseSBjbGVhbiB1cCBhbnl0aGluZy5cbiogSXQgaXMgaW50ZW5kZWQgYmUgdXNlZCB3aXRoIEljb25pZnkgaWNvbiBkYXRhLCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZFxuKi9cbmZ1bmN0aW9uIGNsZWFuVXBJbm5lckhUTUwoaHRtbCkge1xuXHRpZiAocG9saWN5ID09PSB2b2lkIDApIGNyZWF0ZVBvbGljeSgpO1xuXHRyZXR1cm4gcG9saWN5ID8gcG9saWN5LmNyZWF0ZUhUTUwoaHRtbCkgOiBodG1sO1xufVxuXG5jb25zdCBkZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICBpbmxpbmU6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IFNWRyBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IHN2Z0RlZmF1bHRzID0ge1xuICAgICd4bWxucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgJ3htbG5zWGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAncm9sZSc6ICdpbWcnLFxufTtcbi8qKlxuICogU3R5bGUgbW9kZXNcbiAqL1xuY29uc3QgY29tbW9uUHJvcHMgPSB7XG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG59O1xuY29uc3QgbW9ub3RvbmVQcm9wcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxufTtcbmNvbnN0IGNvbG9yZWRQcm9wcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG59O1xuLy8gRHluYW1pY2FsbHkgYWRkIGNvbW1vbiBwcm9wcyB0byB2YXJpYWJsZXMgYWJvdmVcbmNvbnN0IHByb3BzVG9BZGQgPSB7XG4gICAgSW1hZ2U6ICd2YXIoLS1zdmcpJyxcbiAgICBSZXBlYXQ6ICduby1yZXBlYXQnLFxuICAgIFNpemU6ICcxMDAlIDEwMCUnLFxufTtcbmNvbnN0IHByb3BzVG9BZGRUbyA9IHtcbiAgICBXZWJraXRNYXNrOiBtb25vdG9uZVByb3BzLFxuICAgIG1hc2s6IG1vbm90b25lUHJvcHMsXG4gICAgYmFja2dyb3VuZDogY29sb3JlZFByb3BzLFxufTtcbmZvciAoY29uc3QgcHJlZml4IGluIHByb3BzVG9BZGRUbykge1xuICAgIGNvbnN0IGxpc3QgPSBwcm9wc1RvQWRkVG9bcHJlZml4XTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHNUb0FkZCkge1xuICAgICAgICBsaXN0W3ByZWZpeCArIHByb3BdID0gcHJvcHNUb0FkZFtwcm9wXTtcbiAgICB9XG59XG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBjdXN0b21pc2F0aW9ucyBmb3IgaW5saW5lIGljb25cbiAqL1xuY29uc3QgaW5saW5lRGVmYXVsdHMgPSB7XG4gICAgLi4uZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zLFxuICAgIGlubGluZTogdHJ1ZSxcbn07XG4vKipcbiAqIEZpeCBzaXplOiBhZGQgJ3B4JyB0byBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIGZpeFNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAodmFsdWUubWF0Y2goL15bLTAtOS5dKyQvKSA/ICdweCcgOiAnJyk7XG59XG4vKipcbiAqIFJlbmRlciBpY29uXG4gKi9cbmNvbnN0IHJlbmRlciA9IChcbi8vIEljb24gbXVzdCBiZSB2YWxpZGF0ZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvblxuaWNvbiwgXG4vLyBQYXJ0aWFsIHByb3BlcnRpZXNcbnByb3BzLCBcbi8vIEljb24gbmFtZVxubmFtZSkgPT4ge1xuICAgIC8vIEdldCBkZWZhdWx0IHByb3BlcnRpZXNcbiAgICBjb25zdCBkZWZhdWx0UHJvcHMgPSBwcm9wcy5pbmxpbmVcbiAgICAgICAgPyBpbmxpbmVEZWZhdWx0c1xuICAgICAgICA6IGRlZmF1bHRFeHRlbmRlZEljb25DdXN0b21pc2F0aW9ucztcbiAgICAvLyBHZXQgYWxsIGN1c3RvbWlzYXRpb25zXG4gICAgY29uc3QgY3VzdG9taXNhdGlvbnMgPSBtZXJnZUN1c3RvbWlzYXRpb25zKGRlZmF1bHRQcm9wcywgcHJvcHMpO1xuICAgIC8vIENoZWNrIG1vZGVcbiAgICBjb25zdCBtb2RlID0gcHJvcHMubW9kZSB8fCAnc3ZnJztcbiAgICAvLyBDcmVhdGUgc3R5bGVcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuICAgIGNvbnN0IGN1c3RvbVN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gICAgLy8gQ3JlYXRlIFNWRyBjb21wb25lbnQgcHJvcGVydGllc1xuICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0ge1xuICAgICAgICAuLi4obW9kZSA9PT0gJ3N2ZycgPyBzdmdEZWZhdWx0cyA6IHt9KSxcbiAgICB9O1xuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGljb25OYW1lID0gc3RyaW5nVG9JY29uKG5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGljb25OYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gWydpY29uaWZ5J107XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IFtcbiAgICAgICAgICAgICAgICAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgICdwcmVmaXgnLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChpY29uTmFtZVtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ljb25pZnktLScgKyBpY29uTmFtZVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50UHJvcHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IGVsZW1lbnQgcHJvcGVydGllc1xuICAgIGZvciAobGV0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgLy8gUHJvcGVydGllcyB0byBpZ25vcmVcbiAgICAgICAgICAgIGNhc2UgJ2ljb24nOlxuICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgICAgY2FzZSAnb25Mb2FkJzpcbiAgICAgICAgICAgIGNhc2UgJ21vZGUnOlxuICAgICAgICAgICAgY2FzZSAnc3NyJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZhbGxiYWNrJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEZvcndhcmQgcmVmXG4gICAgICAgICAgICBjYXNlICdfcmVmJzpcbiAgICAgICAgICAgICAgICBjb21wb25lbnRQcm9wcy5yZWYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIE1lcmdlIGNsYXNzIG5hbWVzXG4gICAgICAgICAgICBjYXNlICdjbGFzc05hbWUnOlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3BzW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICAoY29tcG9uZW50UHJvcHNba2V5XSA/IGNvbXBvbmVudFByb3BzW2tleV0gKyAnICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBCb29sZWFuIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNhc2UgJ2lubGluZSc6XG4gICAgICAgICAgICBjYXNlICdoRmxpcCc6XG4gICAgICAgICAgICBjYXNlICd2RmxpcCc6XG4gICAgICAgICAgICAgICAgY3VzdG9taXNhdGlvbnNba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBGbGlwIGFzIHN0cmluZzogJ2hvcml6b250YWwsdmVydGljYWwnXG4gICAgICAgICAgICBjYXNlICdmbGlwJzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBmbGlwRnJvbVN0cmluZyhjdXN0b21pc2F0aW9ucywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIENvbG9yOiBjb3B5IHRvIHN0eWxlXG4gICAgICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgICAgICAgc3R5bGUuY29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFJvdGF0aW9uIGFzIHN0cmluZ1xuICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21pc2F0aW9uc1trZXldID0gcm90YXRlRnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9taXNhdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhcmlhLWhpZGRlblxuICAgICAgICAgICAgY2FzZSAnYXJpYUhpZGRlbic6XG4gICAgICAgICAgICBjYXNlICdhcmlhLWhpZGRlbic6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudFByb3BzWydhcmlhLWhpZGRlbiddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIENvcHkgbWlzc2luZyBwcm9wZXJ0eSBpZiBpdCBkb2VzIG5vdCBleGlzdCBpbiBjdXN0b21pc2F0aW9uc1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFByb3BzW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRQcm9wc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIGljb25cbiAgICBjb25zdCBpdGVtID0gaWNvblRvU1ZHKGljb24sIGN1c3RvbWlzYXRpb25zKTtcbiAgICBjb25zdCByZW5kZXJBdHRyaWJzID0gaXRlbS5hdHRyaWJ1dGVzO1xuICAgIC8vIElubGluZSBkaXNwbGF5XG4gICAgaWYgKGN1c3RvbWlzYXRpb25zLmlubGluZSkge1xuICAgICAgICBzdHlsZS52ZXJ0aWNhbEFsaWduID0gJy0wLjEyNWVtJztcbiAgICB9XG4gICAgaWYgKG1vZGUgPT09ICdzdmcnKSB7XG4gICAgICAgIC8vIEFkZCBzdHlsZVxuICAgICAgICBjb21wb25lbnRQcm9wcy5zdHlsZSA9IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgLi4uY3VzdG9tU3R5bGUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZCBpY29uIHN0dWZmXG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29tcG9uZW50UHJvcHMsIHJlbmRlckF0dHJpYnMpO1xuICAgICAgICAvLyBDb3VudGVyIGZvciBpZHMgYmFzZWQgb24gXCJpZFwiIHByb3BlcnR5IHRvIHJlbmRlciBpY29ucyBjb25zaXN0ZW50bHkgb24gc2VydmVyIGFuZCBjbGllbnRcbiAgICAgICAgbGV0IGxvY2FsQ291bnRlciA9IDA7XG4gICAgICAgIGxldCBpZCA9IHByb3BzLmlkO1xuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gQ29udmVydCAnLScgdG8gJ18nIHRvIGF2b2lkIGVycm9ycyBpbiBhbmltYXRpb25zXG4gICAgICAgICAgICBpZCA9IGlkLnJlcGxhY2UoLy0vZywgJ18nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgaWNvbiBzdHVmZlxuICAgICAgICBjb21wb25lbnRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9IHtcbiAgICAgICAgICAgIF9faHRtbDogY2xlYW5VcElubmVySFRNTChyZXBsYWNlSURzKGl0ZW0uYm9keSwgaWQgPyAoKSA9PiBpZCArICdJRCcgKyBsb2NhbENvdW50ZXIrKyA6ICdpY29uaWZ5UmVhY3QnKSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdzdmcnLCBjb21wb25lbnRQcm9wcyk7XG4gICAgfVxuICAgIC8vIFJlbmRlciA8c3Bhbj4gd2l0aCBzdHlsZVxuICAgIGNvbnN0IHsgYm9keSwgd2lkdGgsIGhlaWdodCB9ID0gaWNvbjtcbiAgICBjb25zdCB1c2VNYXNrID0gbW9kZSA9PT0gJ21hc2snIHx8XG4gICAgICAgIChtb2RlID09PSAnYmcnID8gZmFsc2UgOiBib2R5LmluZGV4T2YoJ2N1cnJlbnRDb2xvcicpICE9PSAtMSk7XG4gICAgLy8gR2VuZXJhdGUgU1ZHXG4gICAgY29uc3QgaHRtbCA9IGljb25Ub0hUTUwoYm9keSwge1xuICAgICAgICAuLi5yZW5kZXJBdHRyaWJzLFxuICAgICAgICB3aWR0aDogd2lkdGggKyAnJyxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAnJyxcbiAgICB9KTtcbiAgICAvLyBHZW5lcmF0ZSBzdHlsZVxuICAgIGNvbXBvbmVudFByb3BzLnN0eWxlID0ge1xuICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgJy0tc3ZnJzogc3ZnVG9VUkwoaHRtbCksXG4gICAgICAgICd3aWR0aCc6IGZpeFNpemUocmVuZGVyQXR0cmlicy53aWR0aCksXG4gICAgICAgICdoZWlnaHQnOiBmaXhTaXplKHJlbmRlckF0dHJpYnMuaGVpZ2h0KSxcbiAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgIC4uLih1c2VNYXNrID8gbW9ub3RvbmVQcm9wcyA6IGNvbG9yZWRQcm9wcyksXG4gICAgICAgIC4uLmN1c3RvbVN0eWxlLFxuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBjb21wb25lbnRQcm9wcyk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpc2Ugc3R1ZmZcbiAqL1xuLy8gRW5hYmxlIHNob3J0IG5hbWVzXG5hbGxvd1NpbXBsZU5hbWVzKHRydWUpO1xuLy8gU2V0IEFQSSBtb2R1bGVcbnNldEFQSU1vZHVsZSgnJywgZmV0Y2hBUElNb2R1bGUpO1xuLyoqXG4gKiBCcm93c2VyIHN0dWZmXG4gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgX3dpbmRvdyA9IHdpbmRvdztcbiAgICAvLyBMb2FkIGljb25zIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByZWxvYWRcIlxuICAgIGlmIChfd2luZG93Lkljb25pZnlQcmVsb2FkICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgcHJlbG9hZCA9IF93aW5kb3cuSWNvbmlmeVByZWxvYWQ7XG4gICAgICAgIGNvbnN0IGVyciA9ICdJbnZhbGlkIEljb25pZnlQcmVsb2FkIHN5bnRheC4nO1xuICAgICAgICBpZiAodHlwZW9mIHByZWxvYWQgPT09ICdvYmplY3QnICYmIHByZWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIChwcmVsb2FkIGluc3RhbmNlb2YgQXJyYXkgPyBwcmVsb2FkIDogW3ByZWxvYWRdKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdGVtIGlzIGFuIG9iamVjdCBhbmQgbm90IG51bGwvYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtIGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciAnaWNvbnMnIGFuZCAncHJlZml4J1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0uaWNvbnMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbS5wcmVmaXggIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgaWNvbiBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICFhZGRDb2xsZWN0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNldCBBUEkgZnJvbSBnbG9iYWwgXCJJY29uaWZ5UHJvdmlkZXJzXCJcbiAgICBpZiAoX3dpbmRvdy5JY29uaWZ5UHJvdmlkZXJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gX3dpbmRvdy5JY29uaWZ5UHJvdmlkZXJzO1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVycyA9PT0gJ29iamVjdCcgJiYgcHJvdmlkZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gJ0ljb25pZnlQcm92aWRlcnNbJyArIGtleSArICddIGlzIGludmFsaWQuJztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3ZpZGVyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXNvdXJjZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGRBUElQcm92aWRlcihrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBJY29uQ29tcG9uZW50KHByb3BzKSB7XG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoISFwcm9wcy5zc3IpO1xuICAgIGNvbnN0IFthYm9ydCwgc2V0QWJvcnRdID0gdXNlU3RhdGUoe30pO1xuICAgIC8vIEdldCBpbml0aWFsIHN0YXRlXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKG1vdW50ZWQpIHtcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBwcm9wcy5pY29uO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIEljb24gYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG5hbWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBnZXRJY29uRGF0YShuYW1lKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZShnZXRJbml0aWFsU3RhdGUoISFwcm9wcy5zc3IpKTtcbiAgICAvLyBDYW5jZWwgbG9hZGluZ1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYWJvcnQuY2FsbGJhY2s7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHNldEFib3J0KHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGFuZ2Ugc3RhdGUgaWYgaXQgaXMgZGlmZmVyZW50XG4gICAgZnVuY3Rpb24gY2hhbmdlU3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHN0YXRlKSAhPT0gSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBzZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICBmdW5jdGlvbiB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBuYW1lID0gcHJvcHMuaWNvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gSWNvbiBhcyBvYmplY3RcbiAgICAgICAgICAgIGNoYW5nZVN0YXRlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV3IGljb24gb3IgZ290IGljb24gZGF0YVxuICAgICAgICBjb25zdCBkYXRhID0gZ2V0SWNvbkRhdGEobmFtZSk7XG4gICAgICAgIGlmIChjaGFuZ2VTdGF0ZSh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkIGljb24sIHVwZGF0ZSBzdGF0ZSB3aGVuIGRvbmVcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGxvYWRJY29ucyhbbmFtZV0sIHVwZGF0ZVN0YXRlKTtcbiAgICAgICAgICAgICAgICBzZXRBYm9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIEljb24gZGF0YSBpcyBhdmFpbGFibGU6IHRyaWdnZXIgb25Mb2FkIGNhbGxiYWNrIGlmIHByZXNlbnRcbiAgICAgICAgICAgICAgICAoX2EgPSBwcm9wcy5vbkxvYWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHByb3BzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3VudGVkIHN0YXRlLCBjbGVhbnVwIGZvciBsb2FkZXJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRNb3VudGVkKHRydWUpO1xuICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9LCBbXSk7XG4gICAgLy8gSWNvbiBjaGFuZ2VkIG9yIGNvbXBvbmVudCBtb3VudGVkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMuaWNvbiwgbW91bnRlZF0pO1xuICAgIC8vIFJlbmRlciBpY29uXG4gICAgY29uc3QgeyBuYW1lLCBkYXRhIH0gPSBzdGF0ZTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICA/IHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICA6IHByb3BzLmZhbGxiYWNrXG4gICAgICAgICAgICAgICAgPyBwcm9wcy5mYWxsYmFja1xuICAgICAgICAgICAgICAgIDogY3JlYXRlRWxlbWVudCgnc3BhbicsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcih7XG4gICAgICAgIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gICAgICAgIC4uLmRhdGEsXG4gICAgfSwgcHJvcHMsIG5hbWUpO1xufVxuLyoqXG4gKiBCbG9jayBpY29uXG4gKlxuICogQHBhcmFtIHByb3BzIC0gQ29tcG9uZW50IHByb3BlcnRpZXNcbiAqL1xuY29uc3QgSWNvbiA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IEljb25Db21wb25lbnQoe1xuICAgIC4uLnByb3BzLFxuICAgIF9yZWY6IHJlZixcbn0pKTtcbi8qKlxuICogSW5saW5lIGljb24gKGhhcyBuZWdhdGl2ZSB2ZXJ0aWNhbEFsaWduIHRoYXQgbWFrZXMgaXQgYmVoYXZlIGxpa2UgaWNvbiBmb250KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIENvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKi9cbmNvbnN0IElubGluZUljb24gPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBJY29uQ29tcG9uZW50KHtcbiAgICBpbmxpbmU6IHRydWUsXG4gICAgLi4ucHJvcHMsXG4gICAgX3JlZjogcmVmLFxufSkpO1xuLyoqXG4gKiBJbnRlcm5hbCBBUElcbiAqL1xuY29uc3QgX2FwaSA9IHtcbiAgICBnZXRBUElDb25maWcsXG4gICAgc2V0QVBJTW9kdWxlLFxuICAgIHNlbmRBUElRdWVyeSxcbiAgICBzZXRGZXRjaCxcbiAgICBnZXRGZXRjaCxcbiAgICBsaXN0QVBJUHJvdmlkZXJzLFxufTtcblxuZXhwb3J0IHsgSWNvbiwgSW5saW5lSWNvbiwgX2FwaSwgYWRkQVBJUHJvdmlkZXIsIGFkZENvbGxlY3Rpb24sIGFkZEljb24sIGljb25Ub1NWRyBhcyBidWlsZEljb24sIGNhbGN1bGF0ZVNpemUsIGdldEljb24sIGljb25Mb2FkZWQsIGxpc3RJY29ucywgbG9hZEljb24sIGxvYWRJY29ucywgcmVwbGFjZUlEcywgc2V0Q3VzdG9tSWNvbkxvYWRlciwgc2V0Q3VzdG9tSWNvbnNMb2FkZXIgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVFbGVtZW50IiwiZm9yd2FyZFJlZiIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZ2V0SWNvbnNUcmVlIiwiZGF0YSIsIm5hbWVzIiwiaWNvbnMiLCJhbGlhc2VzIiwiT2JqZWN0IiwiY3JlYXRlIiwicmVzb2x2ZWQiLCJyZXNvbHZlIiwibmFtZSIsInBhcmVudCIsInZhbHVlIiwiY29uY2F0Iiwia2V5cyIsImZvckVhY2giLCJkZWZhdWx0SWNvbkRpbWVuc2lvbnMiLCJmcmVlemUiLCJsZWZ0IiwidG9wIiwid2lkdGgiLCJoZWlnaHQiLCJkZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9ucyIsInJvdGF0ZSIsInZGbGlwIiwiaEZsaXAiLCJkZWZhdWx0SWNvblByb3BzIiwiZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzIiwiYm9keSIsImhpZGRlbiIsIm1lcmdlSWNvblRyYW5zZm9ybWF0aW9ucyIsIm9iajEiLCJvYmoyIiwicmVzdWx0IiwibWVyZ2VJY29uRGF0YSIsImNoaWxkIiwia2V5IiwiaW50ZXJuYWxHZXRJY29uRGF0YSIsInRyZWUiLCJjdXJyZW50UHJvcHMiLCJwYXJzZSIsIm5hbWUkMSIsInBhcnNlSWNvblNldCIsImNhbGxiYWNrIiwibm90X2ZvdW5kIiwiQXJyYXkiLCJwdXNoIiwiaXRlbSIsIm9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cyIsInByb3ZpZGVyIiwiY2hlY2tPcHRpb25hbFByb3BzIiwiZGVmYXVsdHMiLCJwcm9wIiwicXVpY2tseVZhbGlkYXRlSWNvblNldCIsIm9iaiIsInByZWZpeCIsImljb24iLCJkYXRhU3RvcmFnZSIsIm5ld1N0b3JhZ2UiLCJtaXNzaW5nIiwiU2V0IiwiZ2V0U3RvcmFnZSIsInByb3ZpZGVyU3RvcmFnZSIsImFkZEljb25TZXQiLCJzdG9yYWdlIiwiYWRkIiwiYWRkSWNvblRvU3RvcmFnZSIsImVyciIsImxpc3RJY29ucyIsImFsbEljb25zIiwicHJvdmlkZXJzIiwicHJvdmlkZXIkMSIsInByZWZpeGVzIiwicHJlZml4JDEiLCJtYXAiLCJtYXRjaEljb25OYW1lIiwic3RyaW5nVG9JY29uIiwidmFsaWRhdGUiLCJhbGxvd1NpbXBsZU5hbWUiLCJjb2xvblNlcGFyYXRlZCIsInNwbGl0Iiwic2xpY2UiLCJsZW5ndGgiLCJzaGlmdCIsInBvcCIsInZhbGlkYXRlSWNvbk5hbWUiLCJkYXNoU2VwYXJhdGVkIiwiam9pbiIsInNpbXBsZU5hbWVzIiwiYWxsb3dTaW1wbGVOYW1lcyIsImFsbG93IiwiZ2V0SWNvbkRhdGEiLCJpY29uTmFtZSIsImhhcyIsImFkZEljb24iLCJhZGRDb2xsZWN0aW9uIiwiYWRkZWQiLCJpY29uTG9hZGVkIiwiZ2V0SWNvbiIsImRlZmF1bHRJY29uU2l6ZUN1c3RvbWlzYXRpb25zIiwiZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyIsInVuaXRzU3BsaXQiLCJ1bml0c1Rlc3QiLCJjYWxjdWxhdGVTaXplIiwic2l6ZSIsInJhdGlvIiwicHJlY2lzaW9uIiwiTWF0aCIsImNlaWwiLCJvbGRQYXJ0cyIsIm5ld1BhcnRzIiwiY29kZSIsImlzTnVtYmVyIiwidGVzdCIsIm51bSIsInBhcnNlRmxvYXQiLCJpc05hTiIsInNwbGl0U1ZHRGVmcyIsImNvbnRlbnQiLCJ0YWciLCJkZWZzIiwiaW5kZXgiLCJpbmRleE9mIiwic3RhcnQiLCJlbmQiLCJlbmRFbmQiLCJ0cmltIiwibWVyZ2VEZWZzQW5kQ29udGVudCIsIndyYXBTVkdDb250ZW50IiwiaXNVbnNldEtleXdvcmQiLCJpY29uVG9TVkciLCJjdXN0b21pc2F0aW9ucyIsImZ1bGxJY29uIiwiZnVsbEN1c3RvbWlzYXRpb25zIiwiYm94IiwicHJvcHMiLCJ0cmFuc2Zvcm1hdGlvbnMiLCJyb3RhdGlvbiIsInRvU3RyaW5nIiwidGVtcFZhbHVlIiwiZmxvb3IiLCJ1bnNoaWZ0IiwiY3VzdG9taXNhdGlvbnNXaWR0aCIsImN1c3RvbWlzYXRpb25zSGVpZ2h0IiwiYm94V2lkdGgiLCJib3hIZWlnaHQiLCJhdHRyaWJ1dGVzIiwic2V0QXR0ciIsInZpZXdCb3giLCJyZWdleCIsInJhbmRvbVByZWZpeCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJjb3VudGVyIiwicmVwbGFjZUlEcyIsImlkcyIsIm1hdGNoIiwiZXhlYyIsInN1ZmZpeCIsImlkIiwibmV3SUQiLCJlc2NhcGVkSUQiLCJyZXBsYWNlIiwiUmVnRXhwIiwic2V0QVBJTW9kdWxlIiwiZ2V0QVBJTW9kdWxlIiwiY3JlYXRlQVBJQ29uZmlnIiwic291cmNlIiwicmVzb3VyY2VzIiwicGF0aCIsIm1heFVSTCIsInRpbWVvdXQiLCJkYXRhQWZ0ZXJUaW1lb3V0IiwiY29uZmlnU3RvcmFnZSIsImZhbGxCYWNrQVBJU291cmNlcyIsImZhbGxCYWNrQVBJIiwiYWRkQVBJUHJvdmlkZXIiLCJjdXN0b21Db25maWciLCJjb25maWciLCJnZXRBUElDb25maWciLCJsaXN0QVBJUHJvdmlkZXJzIiwiZGV0ZWN0RmV0Y2giLCJmZXRjaCIsImZldGNoTW9kdWxlIiwic2V0RmV0Y2giLCJmZXRjaCQxIiwiZ2V0RmV0Y2giLCJjYWxjdWxhdGVNYXhMZW5ndGgiLCJtYXhIb3N0TGVuZ3RoIiwiaG9zdCIsIm1heCIsInVybCIsInNob3VsZEFib3J0Iiwic3RhdHVzIiwicHJlcGFyZSIsInJlc3VsdHMiLCJtYXhMZW5ndGgiLCJ0eXBlIiwiZ2V0UGF0aCIsInNlbmQiLCJwYXJhbXMiLCJpY29uc0xpc3QiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ1cmkiLCJkZWZhdWx0RXJyb3IiLCJ0aGVuIiwicmVzcG9uc2UiLCJzZXRUaW1lb3V0IiwianNvbiIsImNhdGNoIiwiZmV0Y2hBUElNb2R1bGUiLCJyZW1vdmVDYWxsYmFjayIsInN0b3JhZ2VzIiwiaXRlbXMiLCJsb2FkZXJDYWxsYmFja3MiLCJmaWx0ZXIiLCJyb3ciLCJ1cGRhdGVDYWxsYmFja3MiLCJwZW5kaW5nQ2FsbGJhY2tzRmxhZyIsImhhc1BlbmRpbmciLCJvbGRMZW5ndGgiLCJwZW5kaW5nIiwibG9hZGVkIiwiYWJvcnQiLCJpZENvdW50ZXIiLCJzdG9yZUNhbGxiYWNrIiwicGVuZGluZ1NvdXJjZXMiLCJiaW5kIiwic29ydEljb25zIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImxhc3RJY29uIiwibG9jYWxTdG9yYWdlIiwibGlzdCIsImxpc3RUb0ljb25zIiwiZGVmYXVsdENvbmZpZyIsInNlbmRRdWVyeSIsInBheWxvYWQiLCJxdWVyeSIsImRvbmUiLCJyZXNvdXJjZXNDb3VudCIsInN0YXJ0SW5kZXgiLCJuZXh0SW5kZXgiLCJzdGFydFRpbWUiLCJxdWVyaWVzU2VudCIsImxhc3RFcnJvciIsInRpbWVyIiwicXVldWUiLCJkb25lQ2FsbGJhY2tzIiwicmVzZXRUaW1lciIsImNsZWFyVGltZW91dCIsInN1YnNjcmliZSIsIm92ZXJ3cml0ZSIsImdldFF1ZXJ5U3RhdHVzIiwicXVlcmllc1BlbmRpbmciLCJmYWlsUXVlcnkiLCJjbGVhclF1ZXVlIiwibW9kdWxlUmVzcG9uc2UiLCJpc0Vycm9yIiwicXVldWVkIiwiZXhlY05leHQiLCJyZXNvdXJjZSIsInN0YXR1cyQxIiwiaW5pdFJlZHVuZGFuY3kiLCJjZmciLCJxdWVyaWVzIiwiY2xlYW51cCIsInF1ZXJ5Q2FsbGJhY2siLCJkb25lQ2FsbGJhY2siLCJxdWVyeSQxIiwiZXJyb3IiLCJmaW5kIiwiaW5zdGFuY2UiLCJzZXRJbmRleCIsImdldEluZGV4IiwiZW1wdHlDYWxsYmFjayQxIiwicmVkdW5kYW5jeUNhY2hlIiwiZ2V0UmVkdW5kYW5jeUNhY2hlIiwicmVkdW5kYW5jeSIsImNhY2hlZFJldW5kYW5jeSIsInNlbmRBUElRdWVyeSIsInRhcmdldCIsImFwaSIsImNhY2hlZCIsIm1vZHVsZUtleSIsImVtcHR5Q2FsbGJhY2siLCJsb2FkZWROZXdJY29ucyIsImljb25zTG9hZGVyRmxhZyIsImNoZWNrSWNvbk5hbWVzRm9yQVBJIiwidmFsaWQiLCJpbnZhbGlkIiwicGFyc2VMb2FkZXJSZXNwb25zZSIsImNoZWNrTWlzc2luZyIsInBlbmRpbmdJY29ucyIsImRlbGV0ZSIsInBhcnNlZCIsImNvbnNvbGUiLCJwYXJzZVBvc3NpYmx5QXN5bmNSZXNwb25zZSIsIlByb21pc2UiLCJsb2FkTmV3SWNvbnMiLCJpY29uc1RvTG9hZCIsImljb25zUXVldWVGbGFnIiwiaWNvbnMkMSIsImN1c3RvbUljb25Mb2FkZXIiLCJsb2FkSWNvbiIsImxvYWRJY29ucyIsImljb25TZXQiLCJjbGVhbmVkSWNvbnMiLCJzb3J0ZWRJY29ucyIsImNhbGxDYWxsYmFjayIsIm5ld0ljb25zIiwic291cmNlcyIsImxhc3RQcm92aWRlciIsImxhc3RQcmVmaXgiLCJwcm92aWRlck5ld0ljb25zIiwicGVuZGluZ1F1ZXVlIiwiZnVsZmlsbCIsInJlamVjdCIsImljb25PYmoiLCJzZXRDdXN0b21JY29uc0xvYWRlciIsImxvYWRlciIsInNldEN1c3RvbUljb25Mb2FkZXIiLCJtZXJnZUN1c3RvbWlzYXRpb25zIiwidmFsdWVUeXBlIiwic2VwYXJhdG9yIiwiZmxpcEZyb21TdHJpbmciLCJjdXN0b20iLCJmbGlwIiwic3RyIiwicm90YXRlRnJvbVN0cmluZyIsImRlZmF1bHRWYWx1ZSIsInVuaXRzIiwidmFsdWUkMSIsInBhcnNlSW50IiwiaWNvblRvSFRNTCIsInJlbmRlckF0dHJpYnNIVE1MIiwiYXR0ciIsImVuY29kZVNWR2ZvclVSTCIsInN2ZyIsInN2Z1RvRGF0YSIsInN2Z1RvVVJMIiwicG9saWN5IiwiY3JlYXRlUG9saWN5Iiwid2luZG93IiwidHJ1c3RlZFR5cGVzIiwiY3JlYXRlSFRNTCIsInMiLCJjbGVhblVwSW5uZXJIVE1MIiwiaHRtbCIsImRlZmF1bHRFeHRlbmRlZEljb25DdXN0b21pc2F0aW9ucyIsImlubGluZSIsInN2Z0RlZmF1bHRzIiwiY29tbW9uUHJvcHMiLCJkaXNwbGF5IiwibW9ub3RvbmVQcm9wcyIsImJhY2tncm91bmRDb2xvciIsImNvbG9yZWRQcm9wcyIsInByb3BzVG9BZGQiLCJJbWFnZSIsIlJlcGVhdCIsIlNpemUiLCJwcm9wc1RvQWRkVG8iLCJXZWJraXRNYXNrIiwibWFzayIsImJhY2tncm91bmQiLCJpbmxpbmVEZWZhdWx0cyIsImZpeFNpemUiLCJyZW5kZXIiLCJkZWZhdWx0UHJvcHMiLCJtb2RlIiwic3R5bGUiLCJjdXN0b21TdHlsZSIsImNvbXBvbmVudFByb3BzIiwiY2xhc3NOYW1lcyIsImNsYXNzTmFtZSIsInJlZiIsImNvbG9yIiwicmVuZGVyQXR0cmlicyIsInZlcnRpY2FsQWxpZ24iLCJhc3NpZ24iLCJsb2NhbENvdW50ZXIiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsInVzZU1hc2siLCJkb2N1bWVudCIsIl93aW5kb3ciLCJJY29uaWZ5UHJlbG9hZCIsInByZWxvYWQiLCJlIiwiSWNvbmlmeVByb3ZpZGVycyIsIkljb25Db21wb25lbnQiLCJtb3VudGVkIiwic2V0TW91bnRlZCIsInNzciIsInNldEFib3J0IiwiZ2V0SW5pdGlhbFN0YXRlIiwic3RhdGUiLCJzZXRTdGF0ZSIsImNoYW5nZVN0YXRlIiwibmV3U3RhdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidXBkYXRlU3RhdGUiLCJfYSIsInVuZGVmaW5lZCIsIm9uTG9hZCIsImNhbGwiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwiSWNvbiIsIl9yZWYiLCJJbmxpbmVJY29uIiwiX2FwaSIsImJ1aWxkSWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@iconify/react/dist/iconify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@iconify/react/dist/iconify.js":
/*!*****************************************************!*\
  !*** ./node_modules/@iconify/react/dist/iconify.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Icon: () => (/* binding */ e0),
/* harmony export */   InlineIcon: () => (/* binding */ e1),
/* harmony export */   _api: () => (/* binding */ e2),
/* harmony export */   addAPIProvider: () => (/* binding */ e3),
/* harmony export */   addCollection: () => (/* binding */ e4),
/* harmony export */   addIcon: () => (/* binding */ e5),
/* harmony export */   buildIcon: () => (/* binding */ e6),
/* harmony export */   calculateSize: () => (/* binding */ e7),
/* harmony export */   getIcon: () => (/* binding */ e8),
/* harmony export */   iconLoaded: () => (/* binding */ e9),
/* harmony export */   listIcons: () => (/* binding */ e10),
/* harmony export */   loadIcon: () => (/* binding */ e11),
/* harmony export */   loadIcons: () => (/* binding */ e12),
/* harmony export */   replaceIDs: () => (/* binding */ e13),
/* harmony export */   setCustomIconLoader: () => (/* binding */ e14),
/* harmony export */   setCustomIconsLoader: () => (/* binding */ e15)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#Icon`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#InlineIcon`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#_api`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#addAPIProvider`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#addCollection`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#addIcon`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#buildIcon`);

const e7 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#calculateSize`);

const e8 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#getIcon`);

const e9 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#iconLoaded`);

const e10 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#listIcons`);

const e11 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#loadIcon`);

const e12 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#loadIcons`);

const e13 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#replaceIDs`);

const e14 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#setCustomIconLoader`);

const e15 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/apple/Desktop/thinkhat/inec-press-front/node_modules/@iconify/react/dist/iconify.js#setCustomIconsLoader`);


/***/ })

};
;